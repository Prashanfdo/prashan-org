{"data":[{"content":"\r\nTailwind CSS is a utility-fast CSS framework for building custom UI in a faster & easier way. Tailwind CSS is highly customizable low-level CSS framework.\r\n\r\n## Steps to add Tailwind CSS to a Next.js application.\r\n\r\n## 1. Install Tailwind dependencies.\r\n\r\nif using `yarn`\r\n\r\n```\r\nyarn add -D tailwindcss@latest postcss@latest autoprefixer@latest\r\n```\r\n\r\nif using `npm`\r\n\r\n```\r\nnpm install -D tailwindcss@latest postcss@latest autoprefixer@latest\r\n```\r\n\r\n## 2. Create the configuration files\r\n\r\nif using `yarn`\r\n\r\n```\r\nyarn tailwindcss init -p\r\n```\r\n\r\nif using `npx`\r\n\r\n```\r\nnpx tailwindcss init -p\r\n```\r\n\r\nNow, this command will create a minimal `tailwind.config.js` file at the root directory.\r\n\r\n```\r\n// tailwind.config.js\r\nmodule.exports = {\r\n purge: [],\r\n darkMode: false, // or 'media' or 'class'\r\n theme: {\r\n extend: {},\r\n },\r\n variants: {\r\n extend: {},\r\n },\r\n plugins: [],\r\n}\r\n```\r\n\r\nThat also creates a `postcss.config.js` file -\r\n\r\n```\r\nmodule.exports = {\r\n plugins: {\r\n tailwindcss: {},\r\n autoprefixer: {},\r\n },\r\n}\r\n```\r\n\r\n## 3. Configure the Tailwind\r\n\r\nIn `tailwind.config.js` file, configure the `purge` option with the paths to all the pages & components so Tailwind can tree-shake unused styles in production builds.\r\n\r\n```\r\npurge: ['./pages/**/*.{js,ts,jsx,tsx}', './components/**/*.{js,ts,jsx,tsx}']\r\n```\r\n\r\nAgain if you want to use `dark mode`, change the option -\r\n\r\n```\r\ndarkmode: 'class';\r\n```\r\n\r\n## 4. Include Tailwind in CSS\r\n\r\nopen the `./styles/global.css` file and the following lines of code -\r\n\r\n```\r\n@tailwind base;\r\n@tailwind components;\r\n@tailwind utilities;\r\n```\r\n\r\n## 5. Add Tailwind CSS IntelliSense to VS Code\r\n\r\nFor the autocomplete features for Tailwind CSS classes in VS Code, Install the plugin â€” [Tailwind CSS IntelliSense](https://marketplace.visualstudio.com/items?itemName=bradlc.vscode-tailwindcss)\r\n","data":{"draft":false,"image":"/assets/images/blog/9.jpg","title":"Add Tailwind CSS to Next.js","tags":["react"],"date":"2021-09-05T00:00:00.000Z"},"slug":"10-add-tailwind-css-to-next-js"},{"content":"\r\nIn Nextjs, a route (page on your website) is created by simply creating a React component inside the pages folder. If for example you create a dashboard.tsx file inside the pages folder then the component inside this file will be rendered for a user visiting _www.example.com/dashboard._\r\n\r\nIn order to make a route only accessible to authenticated users, we need to find a way to be able to check whether the user is authenticated when they try to access the page.\r\n\r\nImagine having a room with all your really important private items and secrets inside, you donâ€™t want anyone to be able to see whatâ€™s inside unless you have explicitly allowed them to right? Right!\r\n\r\nImagine that people started entering your room, and itâ€™s only when they get inside that you can ask the ones that are not meant to be there to leave. This is what would happen if you check if a user is authenticated directly in the route component itself.\r\n\r\nNow imagine we could have a reception area in front of this room, that would only let people into the room that are actually allowed in. This sounds like a better plan doesnâ€™t it? We can achieve this by wrapping the page component in an authentication component.\r\n\r\n**Prerequisites:**\r\n\r\nPlease setup the two following projects to be able to easily follow this tutorial.\r\n\r\n- Nextjs project setup with Typescript: [Nextjs docs](https://nextjs.org/docs/getting-started)\r\n- Basic Hello World ExpressJS app: [Express docs](https://expressjs.com/en/starter/installing.html)\r\n\r\n## Create a simple express API to test the frontend\r\n\r\nLetâ€™s jump to the Backend for a few minutes!\r\n\r\nWe are not going to go into how to setup an express server in node as this is a prerequisite for this tutorial, but you can copy this code into the index.js file of your express app in order to setup a simple GET endpoint to allow us to test the frontend functionality.\r\n\r\n```\r\n**_index.js_**const express = require('express');\r\nconst app = express();/*\r\n  Do not use this as authentication on the backend. This is only a simple setup to test the secure route on the frontend.\r\nFor more information on JSON web tokens please checkout this link [https://github.com/auth0/node-jsonwebtoken](https://github.com/auth0/node-jsonwebtoken)\r\n*/const authToken = '123456';app.get('/api/auth/user', (req, res) => {\r\n  const authHeader = req.headers.authorization || '';\r\n  const match = authHeader.match(/Bearer (.+)/); const token = match[1]; if (token !== authToken) {\r\n    return res.status(401).send('Unauthorized');\r\n  } else {\r\n    return res.status(200).json({\r\n      currentUser: {\r\n        full_name: 'John Doe',\r\n      }\r\n    });\r\n  }\r\n});const port = process.env.PORT || 8080;app.listen(port, () => console.log(`App is listening on [http://localhost:${port}`));](http://localhost:${port}`));/)\r\n```\r\n\r\nAll this route does is grab the Token that you pass into the Authorization header from the frontend and compare it to the authToken variable. If they are equal then you get a currentUser object back in response, if not then you get an error response.\r\n\r\n## Creating a secure route component\r\n\r\nLetâ€™s jump back to the Frontend now!\r\n\r\nWe are going to create a wrapper that will take a component as an argument, check whether the user is authenticated, then return the component with the user data. If the user is not authenticated then instead of returning the component we can redirect using (next/router) to the homepage or login page.\r\n\r\n### Create api service\r\n\r\nIn order to respect the principle of separation of concerns, we will create a file which we will call api-service.ts inside a folder called helpers.\r\n\r\nWe shall create a simple fetch request to our backend user authentication endpoint. We need to pass an auth token in the Authorization header to check whether the token is valid. Even if the user has a token from a previous valid login, the token could be expired, therefore we always need to check.\r\n\r\n```\r\n**_./helpers/api-service.ts_**const apiBaseUrl: string = process.env.NODE_ENV === 'production'\r\n  ? 'https://example.com/api'\r\n  : 'http://localhost:8080/api';export const findUser = (token: string) => fetch(`${apiBaseUrl}/auth/user`, {\r\n  method: 'GET',\r\n  headers: {\r\n    Authorization: `Bearer ${token}`,\r\n  },\r\n});\r\n```\r\n\r\n### Create the wrapper\r\n\r\nThe authRoute wrapper will pass the authenticated user data down into the component as a prop. If the user is not authenticated then they will be redirected to the login screen or homepage.\r\n\r\nFirst of all, to ensure that the wrapper doesnâ€™t have any strange side effects, we will just create the wrapper and pass the props down into the returned component.\r\n\r\n```\r\n**_./authentication/authRoute.tsx_**const authRoute = (Component) => {\r\n  return (props) => {\r\n    return <Component {...props} />;\r\n  }\r\n};export default authRoute;\r\n```\r\n\r\nHere it is important to note that we are not doing anything to the inner component. So if we were to wrap a component with this code then the component should act as if this wrapper is not even there.\r\n\r\n### Authenticating the user\r\n\r\nBefore returning the component, we can now authenticate the user. To do this we are going to add the following variables\r\n\r\n```\r\nconst router = useRouter();\r\nconst [user, setUser] = useState(null);\r\nconst [authenticated, setAuthenticated] = useState(false);\r\n```\r\n\r\nThe user variable and the authenticated variable will store the user data and authenticated state respectively. The router variable will allow us to redirect the unauthenticated user to safety (homepage or login page).\r\n\r\n```\r\n**_./authentication/authRoute.tsx_**const authRoute = (Component) => {\r\n  return (props) => {\r\n    const router = useRouter();\r\n    const [user, setUser] = useState(null);\r\n    const [authenticated, setAuthenticated] = useState(false); return <Component {...props} />;\r\n  }\r\n};export default authRoute;\r\n```\r\n\r\nWe then can authenticate the user using the `findUser` helper function we wrote earlier. Do do this we are going to use the `useEffect` hook and async/await as follows.\r\n\r\n```\r\nuseEffect(() => {\r\n  const checkToken = async () => {\r\n    const token = localStorage.getItem(\"token\");\r\n\r\n    if (!token) {\r\n      router.replace(\"/\");\r\n    } else { /* Here you would normally pass in the token to findUser but we are going to pass in '123456' to get a valid response from the server */ /* const response: any = await findUser(JSON.parse(token));*/\r\n\r\n      const response: any = await findUser('123456'); if (!response.ok) {\r\n        localStorage.removeItem(\"token\");\r\n        router.replace(\"/\");\r\n      } else {\r\n        const userData = await response.json();\r\n        if (!userData.currentUser) {\r\n          router.replace(\"/\");\r\n          localStorage.removeItem('token');\r\n        } else {\r\n          setUser(userData.currentUser);\r\n          setAuthenticated(true);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  checkToken();\r\n}, []);\r\n```\r\n\r\nIn order to be able to check whether the user that is trying to access this secure route is authenticated we need to get access to the access token that in our case is saved in local storage. Depending on your setup this might be inside the session storage or a cookie.\r\n\r\nWe check whether the token exists in local storage and if it doesnâ€™t then we donâ€™t need to go any further in the process and we can redirect the user to the homepage or login page.\r\n\r\nOnce we have a token, we are going to use our `findUser` service function to query our API. When we get a response from the server we need to check whether there were any errors and act accordingly. In the code below you can see that if there is an error we redirect the user to the homepage.\r\n\r\n```\r\nconst response: any = await findUser(JSON.parse(token));if (!response.ok) {\r\n  localStorage.removeItem(\"token\");\r\n  router.replace(\"/\");\r\n}\r\n```\r\n\r\nThe last thing we do in this useEffect is to check whether we receive the right object and if so we set the user state to that object and toggle authenticated to true and then call the checkToken function.\r\n\r\n```\r\nif (!userData.currentUser) {\r\nrouter.replace(\"/\");\r\nlocalStorage.removeItem('token');\r\n} else {\r\nsetUser(userData.currentUser);\r\nsetAuthenticated(true);\r\n}\r\n```\r\n\r\nRemember in the beginning of this article we mentioned having a reception area where we could check if the user is authenticated before letting them into the room? Well now we will code the final piece in this authRoute puzzle.\r\n\r\nRight after the `useEffect` we shall add the following if statement:\r\n\r\n```\r\nif (authenticated) {\r\nreturn <Component {...props} user={user} />;\r\n} else {\r\nreturn null;\r\n}\r\n```\r\n\r\nAs you can see, this if statement wraps the initial return component that we coded at the beginning and adds the user object as a prop to the component.\r\n\r\n### What does the whole wrapper look like ?\r\n\r\n```\r\n**_./authentication/authRoute.tsx_**\r\nimport { useRouter } from \"next/router\";\r\nimport { useEffect, useState } from \"react\";\r\nimport { findUser } from '../helpers/api-service';const authRoute = (Component) => {\r\n  return (props) => {\r\n    const router = useRouter();\r\n    const [user, setUser] = useState(null);\r\n    const [authenticated, setAuthenticated] = useState(false);          useEffect(() => {\r\n      const checkToken = async () => {\r\n        const token = localStorage.getItem(\"token\");\r\n\r\n        if (!token) {\r\n          router.replace(\"/\");\r\n        } else {\r\n          const response: any = await findUser(JSON.parse(token));           if (!response.ok) {\r\n            localStorage.removeItem(\"token\");\r\n            router.replace(\"/\");\r\n          } else {\r\n            const userData = await response.json();\r\n            if (!userData.currentUser) {\r\n              router.replace(\"/\");\r\n              localStorage.removeItem('token');\r\n            } else {\r\n              setUser(userData.currentUser);\r\n              setAuthenticated(true);\r\n            }\r\n          }\r\n        }\r\n      }\r\n      checkToken();\r\n    }, []);\r\n\r\n    if (authenticated) {\r\n      return <Component {...props} user={user} />;\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n}; export default authRoute;\r\n```\r\n\r\n### How does this work with an actual component?\r\n\r\nNow the authentication wrapper is finished and we can test our wrapper on a simple component.\r\n\r\nCreate a dashboard component in your pages folder and add the following code.\r\n\r\n```\r\n**_./pages/dashboard.tsx_**\r\nimport React from 'react';\r\nimport authRoute from './authRoute.tsx;const Dashboard = ({ user }) => {\r\n  return (\r\n    <>\r\n      <h1>{`Hello ${user.full_name}}</h1>\r\n    </>\r\n  )\r\n};export default authRoute(Dashboard);\r\n```\r\n\r\n### Run the local version of your app\r\n\r\n```\r\n$ npm run dev\r\n```\r\n\r\nThis is the output that you should see in your browser.\r\n![](/assets/images/blog/10.1.png)\r\n\r\n_Screenshot http://localhost:3000/dashboard_\r\n\r\n## Conclusion\r\n\r\nThere are a few ways to deal with secure routes in React and in Nextjs but this way ensures that you always have access to the authenticated data when the page is rendered, if not you will end up on a login page or homepage in our case.\r\n","data":{"draft":false,"image":"/assets/images/blog/10.jpg","title":"Secure routing in NextJS with TypeScript","tags":["react"],"date":"2021-07-09T00:00:00.000Z"},"slug":"9-secure-routing-in-next-js-with-type-script"},{"content":"\r\nClean code is more than just working code. Clean code is easy to read, simple to understand, and neatly organized. In this article, weâ€™ll look at eight ways we can write cleaner React code.\r\n\r\nWhen going through these suggestions, itâ€™s important to remember thatâ€™s exactly what they are: suggestions. If you disagree with any of them, thatâ€™s completely fine. However, these are practices that Iâ€™ve found helpful in writing my own React code.\r\n\r\nLetâ€™s dive in!\r\n\r\n### 1. Conditional Rendering Only for One Condition\r\n\r\nIf you need to conditionally render something when a condition is `true` and not render anything when a condition is `false`, donâ€™t use a ternary operator. Use the `&&` operator instead.\r\n\r\nBad example:\r\n\r\n```\r\nimport React, { useState } from 'react'\r\n\r\nexport const ConditionalRenderingWhenTrueBad = () => {\r\n  const [showConditionalText, setShowConditionalText] = useState(false)\r\n\r\n  const handleClick = () =>\r\n    setShowConditionalText(showConditionalText => !showConditionalText)\r\n\r\n  return (\r\n    <div>\r\n      <button onClick={handleClick}>Toggle the text</button>\r\n      {showConditionalText ? <p>The condition must be true!</p> : null}\r\n    </div>\r\n  )\r\n}\r\n```\r\n\r\nGood example:\r\n\r\n```\r\nimport React, { useState } from 'react'\r\n\r\nexport const ConditionalRenderingWhenTrueGood = () => {\r\n  const [showConditionalText, setShowConditionalText] = useState(false)\r\n\r\n  const handleClick = () =>\r\n    setShowConditionalText(showConditionalText => !showConditionalText)\r\n\r\n  return (\r\n    <div>\r\n      <button onClick={handleClick}>Toggle the text</button>\r\n      {showConditionalText && <p>The condition must be true!</p>}\r\n    </div>\r\n  )\r\n}\r\n```\r\n\r\n### 2. Conditional Rendering on Either Condition\r\n\r\nIf you need to conditionally render one thing when a condition is `true` and render a different thing when the condition is `false`, use a ternary operator.\r\n\r\nBad example:\r\n\r\n```\r\nimport React, { useState } from 'react'\r\n\r\nexport const ConditionalRenderingBad = () => {\r\n  const [showConditionOneText, setShowConditionOneText] = useState(false)\r\n\r\n  const handleClick = () =>\r\n    setShowConditionOneText(showConditionOneText => !showConditionOneText)\r\n\r\n  return (\r\n    <div>\r\n      <button onClick={handleClick}>Toggle the text</button>\r\n      {showConditionOneText && <p>The condition must be true!</p>}\r\n      {!showConditionOneText && <p>The condition must be false!</p>}\r\n    </div>\r\n  )\r\n}\r\n```\r\n\r\nGood example:\r\n\r\n```\r\nimport React, { useState } from 'react'\r\n\r\nexport const ConditionalRenderingGood = () => {\r\n  const [showConditionOneText, setShowConditionOneText] = useState(false)\r\n\r\n  const handleClick = () =>\r\n    setShowConditionOneText(showConditionOneText => !showConditionOneText)\r\n\r\n  return (\r\n    <div>\r\n      <button onClick={handleClick}>Toggle the text</button>\r\n      {showConditionOneText ? (\r\n        <p>The condition must be true!</p>\r\n      ) : (\r\n        <p>The condition must be false!</p>\r\n      )}\r\n    </div>\r\n  )\r\n}\r\n```\r\n\r\n### 3. Boolean Props\r\n\r\nA truthy prop can be provided to a component with just the prop name without a value like this: `myTruthyProp`. Writing it like `myTruthyProp={true}` is unnecessary.\r\n\r\nBad example:\r\n\r\n```\r\nimport React from 'react'\r\n\r\nconst HungryMessage = ({ isHungry }) => (\r\n  <span>{isHungry ? 'I am hungry' : 'I am full'}</span>\r\n)\r\n\r\nexport const BooleanPropBad = () => (\r\n  <div>\r\n    <span>\r\n      <b>This person is hungry: </b>\r\n    </span>\r\n    <HungryMessage isHungry={true} />\r\n    <br />\r\n    <span>\r\n      <b>This person is full: </b>\r\n    </span>\r\n    <HungryMessage isHungry={false} />\r\n  </div>\r\n)\r\n```\r\n\r\nGood example:\r\n\r\n```\r\nimport React from 'react'\r\n\r\nconst HungryMessage = ({ isHungry }) => (\r\n  <span>{isHungry ? 'I am hungry' : 'I am full'}</span>\r\n)\r\n\r\nexport const BooleanPropGood = () => (\r\n  <div>\r\n    <span>\r\n      <b>This person is hungry: </b>\r\n    </span>\r\n    <HungryMessage isHungry />\r\n    <br />\r\n    <span>\r\n      <b>This person is full: </b>\r\n    </span>\r\n    <HungryMessage isHungry={false} />\r\n  </div>\r\n)\r\n```\r\n\r\n### 4. String Props\r\n\r\nA string prop value can be provided in double-quotes without the use of curly braces or backticks.\r\n\r\nBad example:\r\n\r\n```\r\nimport React from 'react'\r\n\r\nconst Greeting = ({ personName }) => <p>Hi, {personName}!</p>\r\n\r\nexport const StringPropValuesBad = () => (\r\n  <div>\r\n    <Greeting personName={\"John\"} />\r\n    <Greeting personName={'Matt'} />\r\n    <Greeting personName={`Paul`} />\r\n  </div>\r\n)\r\n```\r\n\r\nGood example:\r\n\r\n```\r\nimport React from 'react'\r\n\r\nconst Greeting = ({ personName }) => <p>Hi, {personName}!</p>\r\n\r\nexport const StringPropValuesGood = () => (\r\n  <div>\r\n    <Greeting personName=\"John\" />\r\n    <Greeting personName=\"Matt\" />\r\n    <Greeting personName=\"Paul\" />\r\n  </div>\r\n)\r\n```\r\n\r\n### 5. Event Handler Functions\r\n\r\nIf an event handler only takes a single argument for the `Event` object, you can just provide the function as the event handler like this: `onChange={handleChange}`. You don't need to wrap the function in an anonymous function like this: `onChange={e => handleChange(e)}`.\r\n\r\nBad example:\r\n\r\n```\r\nimport React, { useState } from 'react'\r\n\r\nexport const UnnecessaryAnonymousFunctionsBad = () => {\r\n  const [inputValue, setInputValue] = useState('')\r\n\r\n  const handleChange = e => {\r\n    setInputValue(e.target.value)\r\n  }\r\n\r\n  return (\r\n    <>\r\n      <label htmlFor=\"name\">Name: </label>\r\n      <input id=\"name\" value={inputValue} onChange={e => handleChange(e)} />\r\n    </>\r\n  )\r\n}\r\n```\r\n\r\nGood example:\r\n\r\n```\r\nimport React, { useState } from 'react'\r\n\r\nexport const UnnecessaryAnonymousFunctionsGood = () => {\r\n  const [inputValue, setInputValue] = useState('')\r\n\r\n  const handleChange = e => {\r\n    setInputValue(e.target.value)\r\n  }\r\n\r\n  return (\r\n    <>\r\n      <label htmlFor=\"name\">Name: </label>\r\n      <input id=\"name\" value={inputValue} onChange={handleChange} />\r\n    </>\r\n  )\r\n}\r\n```\r\n\r\n### 6. Passing Components As Props\r\n\r\nWhen passing a component as a prop to another component, you donâ€™t need to wrap this passed component in a function if the component does not accept any props.\r\n\r\nBad example:\r\n\r\n```\r\nimport React from 'react'\r\n\r\nconst CircleIcon = () => (\r\n  <svg height=\"100\" width=\"100\">\r\n    <circle cx=\"50\" cy=\"50\" r=\"40\" stroke=\"black\" stroke-width=\"3\" fill=\"red\" />\r\n  </svg>\r\n)\r\n\r\nconst ComponentThatAcceptsAnIcon = ({ IconComponent }) => (\r\n  <div>\r\n    <p>Below is the icon component prop I was given:</p>\r\n    <IconComponent />\r\n  </div>\r\n)\r\n\r\nexport const UnnecessaryAnonymousFunctionComponentsBad = () => (\r\n  <ComponentThatAcceptsAnIcon IconComponent={() => <CircleIcon />} />\r\n)\r\n```\r\n\r\nGood example:\r\n\r\n```\r\nimport React from 'react'\r\n\r\nconst CircleIcon = () => (\r\n  <svg height=\"100\" width=\"100\">\r\n    <circle cx=\"50\" cy=\"50\" r=\"40\" stroke=\"black\" stroke-width=\"3\" fill=\"red\" />\r\n  </svg>\r\n)\r\n\r\nconst ComponentThatAcceptsAnIcon = ({ IconComponent }) => (\r\n  <div>\r\n    <p>Below is the icon component prop I was given:</p>\r\n    <IconComponent />\r\n  </div>\r\n)\r\n\r\nexport const UnnecessaryAnonymousFunctionComponentsGood = () => (\r\n  <ComponentThatAcceptsAnIcon IconComponent={CircleIcon} />\r\n)\r\n```\r\n\r\n### 7. Undefined Props\r\n\r\nUndefined props are excluded, so donâ€™t worry about providing an `undefined` fallback if it's OK for the prop to be undefined.\r\n\r\nBad example:\r\n\r\n```\r\nimport React from 'react'\r\n\r\nconst ButtonOne = ({ handleClick }) => (\r\n  <button onClick={handleClick || undefined}>Click me</button>\r\n)\r\n\r\nconst ButtonTwo = ({ handleClick }) => {\r\n  const noop = () => {}\r\n\r\n  return <button onClick={handleClick || noop}>Click me</button>\r\n}\r\n\r\nexport const UndefinedPropsBad = () => (\r\n  <div>\r\n    <ButtonOne />\r\n    <ButtonOne handleClick={() => alert('Clicked!')} />\r\n    <ButtonTwo />\r\n    <ButtonTwo handleClick={() => alert('Clicked!')} />\r\n  </div>\r\n)\r\n```\r\n\r\nGood example:\r\n\r\n```\r\nimport React from 'react'\r\n\r\nconst ButtonOne = ({ handleClick }) => (\r\n  <button onClick={handleClick}>Click me</button>\r\n)\r\n\r\nexport const UndefinedPropsGood = () => (\r\n  <div>\r\n    <ButtonOne />\r\n    <ButtonOne handleClick={() => alert('Clicked!')} />\r\n  </div>\r\n)\r\n```\r\n\r\n### 8. Setting State That Relies on the Previous State\r\n\r\nAlways set state as a function of the previous state if the new state relies on the previous state. React state updates can be batched, and not writing your updates this way can lead to unexpected results.\r\n\r\nBad example:\r\n\r\n```\r\nimport React, { useState } from 'react'\r\n\r\nexport const PreviousStateBad = () => {\r\n  const [isDisabled, setIsDisabled] = useState(false)\r\n\r\n  const toggleButton = () => setIsDisabled(!isDisabled)\r\n\r\n  const toggleButton2Times = () => {\r\n    for (let i = 0; i < 2; i++) {\r\n      toggleButton()\r\n    }\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      <button disabled={isDisabled}>\r\n        I'm {isDisabled ? 'disabled' : 'enabled'}\r\n      </button>\r\n      <button onClick={toggleButton}>Toggle button state</button>\r\n      <button onClick={toggleButton2Times}>Toggle button state 2 times</button>\r\n    </div>\r\n  )\r\n}\r\n```\r\n\r\nGood example:\r\n\r\n```\r\nimport React, { useState } from 'react'\r\n\r\nexport const PreviousStateGood = () => {\r\n  const [isDisabled, setIsDisabled] = useState(false)\r\n\r\n  const toggleButton = () => setIsDisabled(isDisabled => !isDisabled)\r\n\r\n  const toggleButton2Times = () => {\r\n    for (let i = 0; i < 2; i++) {\r\n      toggleButton()\r\n    }\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      <button disabled={isDisabled}>\r\n        I'm {isDisabled ? 'disabled' : 'enabled'}\r\n      </button>\r\n      <button onClick={toggleButton}>Toggle button state</button>\r\n      <button onClick={toggleButton2Times}>Toggle button state 2 times</button>\r\n    </div>\r\n  )\r\n}\r\n```\r\n\r\nThe following practices are not React-specific but rather good practices for writing clean code in JavaScript (or any programming language, for that matter).\r\n\r\n- Extract complex logic into clearly named functions.\r\n- Extract magic numbers into constants.\r\n- Use clearly named variables.\r\n","data":{"draft":false,"image":"/assets/images/blog/8.jpg","title":"Write Clean React Code","tags":["react"],"date":"2021-02-24T00:00:00.000Z"},"slug":"8-write-clean-react-code"},{"content":"\r\nNextjs is very popular server rendering library which so many people use it for their development purposes.\r\n\r\nThere are also so many ui libraries for server side rendering frameworks and Material UI is one of them.\r\n\r\nMaterial UI offers React components for faster and easier web development. You can create your own design system, or start with Material Design.\r\n\r\nYou can find many useful information from their websites and components you would like to use it in your project.\r\n\r\n[**Material UI library**](https://material-ui.com/)\r\n\r\n## How to use Next.js with Material UI\r\n\r\nThere are some requirements we should do to use material UI in next.js projects.\r\n\r\n1- Fixing the resolution order\r\n\r\n2- Removing the server side injected CSS\r\n\r\n**Resolution order** in our application needs to as\r\n\r\nOn the server:\r\n\r\n1. app.getInitialProps\r\n2. page.getInitialProps\r\n3. document.getInitialProps\r\n4. app.render\r\n5. page.render\r\n6. document.renderOn the server with error:\r\n7. document.getInitialProps\r\n8. app.render\r\n9. page.render\r\n10. document.renderOn the client\r\n11. app.getInitialProps\r\n12. page.getInitialProps\r\n13. app.render\r\n14. page.render\r\n\r\n### Why we should use it like that?\r\n\r\nServer side rendering frameworks can be a bit tricky sometimes about stylings.\r\n\r\nIf you having issues like flickering screen after you change your root in next.js you should do these changes in your application.\r\n\r\n### How to install and use material UI with next.js\r\n\r\nInstall material-ui to existing next.js project\r\n\r\nyarn\r\n\r\nyarn add @material-ui/core\r\n\r\nnpm\r\n\r\nnpm install @material-ui/core\r\n\r\nIf you are using \\_document.js file already adapt it yours or create new file.\r\n\r\n**\\_document.js**\r\n\r\n```\r\n/* eslint-disable react/jsx-filename-extension */\r\nimport React from 'react';\r\nimport Document, {\r\n  Html, Main, NextScript,\r\n} from 'next/document';\r\nimport { ServerStyleSheets } from '@material-ui/core/styles';\r\n\r\nexport default class MyDocument extends Document {\r\n  render() {\r\n    return (\r\n      <Html lang=\"en\">\r\n        <body>\r\n          <Main />\r\n          <NextScript />\r\n        </body>\r\n      </Html>\r\n    );\r\n  }\r\n}\r\n\r\n// `getInitialProps` belongs to `_document` (instead of `_app`),\r\n// it's compatible with server-side generation (SSG).\r\nMyDocument.getInitialProps = async (ctx) => {\r\n\r\n  // Render app and page and get the context of the page with collected side effects.\r\n  const sheets = new ServerStyleSheets();\r\n  const originalRenderPage = ctx.renderPage;\r\n\r\n  ctx.renderPage = () => originalRenderPage({\r\n    enhanceApp: (App) => (props) => sheets.collect(<App {...props} />),\r\n  });\r\n\r\n  const initialProps = await Document.getInitialProps(ctx);\r\n\r\n  return {\r\n    ...initialProps,\r\n    // Styles fragment is rendered after the app and page rendering finish.\r\n    styles: [...React.Children.toArray(initialProps.styles), sheets.getStyleElement()],\r\n  };\r\n};\r\n```\r\n\r\nIf you are using \\_app.js file already adapt it yours or create new file.\r\n\r\n**\\_app.js**\r\n\r\nThe most important part here is the removing the server side injected CSS.\r\n\r\n```\r\nReact.useEffect(() => {\r\n  // Remove the server-side injected CSS.\r\n  const jssStyles = **_document_**.querySelector('#jss-server-side');\r\n  if (jssStyles) {\r\n    jssStyles.parentElement.removeChild(jssStyles);\r\n  }\r\n}, []);\r\n```\r\n\r\n```\r\nimport React from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport Head from 'next/head';\r\nimport { ThemeProvider } from '@material-ui/core/styles';\r\nimport CssBaseline from '@material-ui/core/CssBaseline';\r\nimport theme from '../src/theme';\r\n\r\nexport default function MyApp(props) {\r\n  const { Component, pageProps } = props;\r\n\r\n  React.useEffect(() => {\r\n    // Remove the server-side injected CSS.\r\n    const jssStyles = document.querySelector('#jss-server-side');\r\n    if (jssStyles) {\r\n      jssStyles.parentElement.removeChild(jssStyles);\r\n    }\r\n  }, []);\r\n\r\n  return (\r\n    <React.Fragment>\r\n      <Head>\r\n        <title>My page</title>\r\n        <meta name=\"viewport\" content=\"minimum-scale=1, initial-scale=1, width=device-width\" />\r\n      </Head>\r\n      <ThemeProvider theme={theme}>\r\n        {/* CssBaseline kickstart an elegant, consistent, and simple baseline to build upon. */}\r\n        <CssBaseline />\r\n        <Component {...pageProps} />\r\n      </ThemeProvider>\r\n    </React.Fragment>\r\n  );\r\n}\r\n\r\nMyApp.propTypes = {\r\n  Component: PropTypes.elementType.isRequired,\r\n  pageProps: PropTypes.object.isRequired,\r\n};\r\n```\r\n\r\nYour application is ready to go! You can test it and now flickering issues is gone and you can able to use material UI properly on your nextjs applications.\r\n","data":{"draft":false,"image":"/assets/images/blog/6.jpg","title":"Next.js with Material-UI","tags":["Next.JS","react","react-hooks"],"date":"2020-06-19T00:00:00.000Z"},"slug":"7-next-js-with-material-ui"},{"content":"\r\n**Problem: the try-catch insanity**\r\n\r\nAgain, I admit I have done it, we all have done it. Another copy and paste job from some tutorial that written up in 2 minutes for the purpose of learning NOT fit for production code that is littered with try-catch.\r\n\r\nHere is a contrived example:\r\n\r\n```\r\nexport function* requestCat() {\r\n try {\r\n  const resp  = yield call(catService.get)\r\n  yield put(actions.requestCatSuccess(resp))\r\n } catch (err) {\r\n  yield put(actions.requestCatError(err))\r\n }\r\n}\r\n\r\nexport function* requestDog() {\r\n try {\r\n  const resp  = yield call(dogService.get)\r\n  yield put(actions.requestDogSuccess(resp))\r\n } catch (err) {\r\n  yield put(actions.requestDogError(err))\r\n }\r\n}\r\n\r\nexport function* catsNDogsSaga() {\r\n yield takeLatest(actions.GET_CAT_REQUEST, requestCat)\r\n yield takeLatest(actions.GET_DOG_REQUEST, requestDog)\r\n}\r\n```\r\n\r\nAs you can see, this is not very good for our mental healthy, letâ€™s see if we can do it better.\r\n\r\n**Option 1: try-catch wrapper**\r\n\r\nAs per Unix Error handling principle â€œIf we donâ€™t have anything interesting to say, keep it quietâ€. Meaning if we donâ€™t have any value to add to solving the error, let it bubble up to the root error handler which is Option-2 below.\r\n\r\nIn the case that we donâ€™t want error to bubble up to root Saga, or we are interested in handling in a specific saga, we wrap the saga generator in a safe generator.\r\n\r\nonError handler can dispatch an event if we want the error to be handled somewhere else in the code base.\r\n\r\nconst onError = (err:any) => yield put(actions.requestError(err))\r\n\r\n```\r\nimport * as actions from '../actions'\r\nimport { catService } from '../catServices'\r\nimport { put, call, takeLatest } from 'redux-saga/effects'\r\n\r\nconst safe = (handler:any = null, saga:any, ...args:any) => function* (action:any) {\r\n  try {\r\n    yield call(saga, ...args, action)\r\n  } catch (err) {\r\n    yield call(handler, ...args, err)\r\n  }\r\n}\r\n\r\nexport function* requestCat() {\r\n  const cats = yield call(catService.get)\r\n  yield put(actions.requestCatSuccess(cats))\r\n}\r\n\r\nexport function* requestDog() {\r\n  const dogs = yield call(catService.get)\r\n  yield put(actions.requestDogSuccess(dogs))\r\n}\r\n\r\nconst onError = (err:any) => {\r\n  console.log(err)\r\n}\r\n\r\nexport function* requestCatSaga() {\r\n yield takeLatest(actions.GET_CAT_REQUEST, safe(onError,requestCat))\r\n yield takeLatest(actions.GET_DOG_REQUEST, safe(onError, requestDog))\r\n}\r\n```\r\n\r\n**Option 2: Global error handler**\r\n\r\nSo we have to options here:\r\n\r\n1. Add an onError function to the middleware option.\r\n\r\n2. Chain a catch function at returned promise of sagaMiddleware.run()\r\n\r\n```\r\nimport { createStore, applyMiddleware, compose } from 'redux'\r\nimport RootReducer from './reducers'\r\nimport createSagaMiddleware from 'redux-saga'\r\nimport rootSaga from './sagas'\r\n\r\n//option 1\r\nconst sagaMiddleware = createSagaMiddleware({\r\n  onError: (err) => {\r\n    store.dispatch({ type: 'ERROR', payload: err })\r\n  }\r\n})\r\n\r\nconst composeEnhancers = ((window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ &&\r\n  (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({ trace: true, traceLimit: 25 }))\r\n  || compose\r\n\r\nconst store = createStore(\r\n  RootReducer,\r\n  composeEnhancers(applyMiddleware(sagaMiddleware))\r\n)\r\n\r\n// option 2\r\nsagaMiddleware.run(rootSaga).done.catch((e:any) => {\r\n  console.log({ message: e.message, source: 'sagaError', stacktrace: e.sagaStack })\r\n  store.dispatch({ type: 'ERROR', payload: e })\r\n})\r\n\r\n// option 2 if on latest mw version\r\nsagaMiddleware.run(rootSagas, store.dispatch).toPromise().catch(e => {\r\n    logger.error({ message: e.message, source: 'sagaError', stacktrace: e.sagaStack })\r\n  store.dispatch({ type: 'ERROR', payload: e })\r\n});\r\n\r\nexport default store\r\n```\r\n","data":{"draft":false,"image":"/assets/images/blog/7.jpg","title":"Redux Saga Error Handling","tags":["react","redux-saga"],"date":"2020-03-02T00:00:00.000Z"},"slug":"6-redux-saga-error-handling"},{"content":"\r\nIf you start using React-Hooks, and your component might need a life cycle method at some point. And, that is when you start using **useEffect()** (a.k.a **Effect Hook**). Then boom!!, you have encountered **an infinite loop behavior,** and you have no idea why the hell is that. If that happens, this article will explain to you why, and how can you prevent.\r\n\r\n## Example Using Effect Hook\r\n\r\nThe code snippet below is the example of using Effect Hook, but it has an infinite loop behavior.\r\n\r\n![](/assets/images/blog/5.1.png)\r\n\r\nA problem snippet code for causing an infinite behavior\r\n\r\n## What does this code do?\r\n\r\n- In a nutshell, the component **_â€œDisplayNameâ€_** has two states which are â€œ**_nameâ€_** and â€œ**_userIdâ€._**\r\n- And it has a function called **_â€œfetchUser()â€_** which handle fetching data from API and set the **_â€œnameâ€._**\r\n- Then, there isâ€œ**_useEffect()â€_** which will call the â€œ**_fetchUser()â€_** after rendering a DOM element.\r\n\r\n## Where is the problem?\r\n\r\n- The â€œ**_useEffect()â€,_** will run after the initial render, then invoke the â€œ**_fetchUser()â€._**\r\n- Inside the â€œ**_fetchUser_**â€, it will update the state â€œ**_name_**â€ on line 9. Then it will trigger the component to re-render again.\r\n- As a result, â€œ**_useEffect()â€_** will run again and update the state. Next, the whole process repeats again, and you're trapped inside an infinite loop.\r\n\r\n![](/assets/images/blog/5.2.png)\r\n\r\nThe diagram of Infinite loop behavior\r\n\r\n## The Solution for Infinite Behavior\r\n\r\n![](/assets/images/blog/5.3.png)\r\n\r\nA solution snippet code for an infinite behavior\r\n\r\n> â€œYou can tell React to _skip_ applying an effect if certain values havenâ€™t changed between re-renders. To do so, pass an array as an optional second argument to useEffectâ€, from the official [documentation](https://reactjs.org/docs/hooks-effect.html#tip-optimizing-performance-by-skipping-effects).\r\n\r\nIn the snippet above, we now have an optional second argument **[userId]** passed in the â€œ**_useEffect()_**â€.\r\n\r\n**By providing [userId] as a second argument**_,_ we are just telling â€œ**_useEffect()â€_** to run only if the certain value (userId) has changed between the component re-renders.\r\n\r\nHere below, Iâ€™ve provided a simple diagram for the sake of simplicity.\r\n\r\n![](/assets/images/blog/5.4.png)\r\n\r\nThe diagram of skipping useEffect\r\n\r\nAnd now, weâ€™ve escaped from the infinite world !!.\r\n","data":{"draft":false,"image":"/assets/images/blog/5.jpg","title":"Taming React Hook useEffect Infinite Loop Inside","tags":["react","react-hooks"],"date":"2019-07-24T00:00:00.000Z"},"slug":"5-how-to-fix-the-infinite-loop-inside-use-effect-react-hooks"},{"content":"\r\nThis post is going to cover this process use the Identity Scaffolding feature available in Visual Studio.\r\n\r\n## Sample\r\n\r\nFor this example, Iâ€™m starting with a new web app created using the following command.\r\n\r\ndotnet new webapp\r\n\r\nIf you have any of the .NET Core 3 previews installed I recommend adding a **global.json** file in the directory where the application is to be created before running the application creation. I had some issues with the scaffolding in the current preview. The following is the contents of my **global.json** for an example.\r\n\r\n{ \"sdk\": { \"version\": \"2.2.104\" } }\r\n\r\n## Scaffolding\r\n\r\nIn Visual Studio right-click on the project and select **Add > New Scaffolded Item**.\r\n\r\n![](/assets/images/blog/4.1.png)\r\n\r\nOn the **Add Scaffold** dialog in the left list select **Identity** in the middle area we want the **Identity** item and then click the **Add** button.\r\n![](/assets/images/blog/4.2.png)\r\n\r\nNext, on the **Add Identity** dialog, you get a chance to pick which parts of the provided identity you want to override. Iâ€™m going to take the default for all the values. The one exception is the **Data context class** which Iâ€™m using the plus button to the right of the field to add a new one since this project doesnâ€™t currently have any data access in it. When done click the **Add** button.\r\n\r\n![](/assets/images/blog/4.3.png)\r\n\r\nAfter a minute or so identity generation will be complete and a text file will so with some follow up steps. Because of the project type, we started with the only one we need to do anything with is the entity framework migrations. The following are the instructions from the file that will get your database to create/updated with the new data needed to support ASP.NET Coreâ€™s Identity.\r\n\r\n> _The generated database code requires Entity Framework Core Migrations. Run the following commands:_\r\n>\r\n> _1. dotnet ef migrations add CreateIdentitySchema  \r\n> 2. dotnet ef database update_\r\n>\r\n> \\_Or from the Visual Studio Package Manager Console:\r\n>\r\n> 1. Add-Migration CreateIdentitySchema\r\n> 2. Update-Database\\_\r\n\r\nFinally, in the **Pages/Shared** directory open the **\\_Layout.cshtml** file and add the following to where you want to show the Register and Login links. I added this right after the existing navigation links.\r\n\r\n```\r\n<partial name=\"_LoginPartial\"/>\r\n```\r\n","data":{"draft":false,"image":"/assets/images/blog/4.jpg","title":"ASP.NET Core - Identity Scaffolding","tags":["dotnet","aspcore"],"date":"2019-04-08T00:00:00.000Z"},"slug":"4-asp-net-core-identity-scaffolding"},{"content":"\r\n**TL;DR** - Wrap your custom hook in a component and shallow render it to test implementation details.\r\n\r\n### Test Strategies\r\n\r\nThere are broadly two strategies to test our React codebase.\r\n\r\n1.  Testing user observable behaviour\r\n2.  Testing implementation details\r\n\r\n#### Testing user observable behaviour\r\n\r\nTesting user observable behaviour means writing tests against components that test\r\n\r\n- how the component is rendered\r\n- how the component is re-rendered when user interacts with the DOM\r\n- how props/state control what is rendered\r\n\r\nConsider the following component - `Greet`\r\n\r\n```\r\nfunction Greet({ user = 'User' }) {\r\n  const [name, setName] = React.useState(user);\r\n\r\n  return <div onClick={() => setName('Pinocchio')}>Hello, {name}!</div>;\r\n}\r\n\r\n```\r\n\r\nTesting the user observable behaviour in `Greet` would mean\r\n\r\n- test if `Greet` is rendered without crashing\r\n- test if `Hello, User!` is rendered when user prop is not passed\r\n- test if `Hello, Bruce!` is rendered when `Bruce` is passed as value to `user` prop\r\n- test if the text changes to `Hello, Pinocchio!` when the user clicks on the element\r\n\r\n#### Testing implementation details\r\n\r\nTesting implementation details means writing tests against state logic that test\r\n\r\n- how the state is initialized with default/prop values\r\n- how the state changes when handlers are invoked\r\n\r\nConsider the same component - `Greet`\r\n\r\n```\r\nfunction Greet({ user = 'User' }) {\r\n  const [name, setName] = React.useState(user);\r\n\r\n  return <div onClick={() => setName('Pinocchio')}>Hello, {name}!</div>;\r\n}\r\n\r\n```\r\n\r\nTesting implementation details in `Greet` would mean\r\n\r\n- test if `name` is set to default value `User` when user prop is not passed to `Greet`\r\n- test if `name` is set to prop value when user prop is passed to `Greet`\r\n- test if `name` is updated when `setName` is invoked\r\n\r\n### Testing custom hooks with Enzyme\r\n\r\n_Note: Please make sure your React version is `^16.8.5`. Hooks won't re-render components with enzyme shallow render in previous versions and the React team fixed it in this release. If your React version is below that, you might have to use enzyme mount and `.update()` your wrapper after each change to test the re-render._\r\n\r\nTesting implementation details might seem unnecessary and might even be considered as a bad practice when you are writing tests against components that contains presentational (UI) logic and render elements to the DOM. But **custom hooks** contain only **state logic** and it is imperative that we test the implementation details thoroughly so we know exactly how our custom hook will behave within a component.\r\n\r\nLet's write a custom hook to update and validate a form field.\r\n\r\n```\r\n/* useFormField.js */\r\n\r\nimport React from 'react';\r\n\r\nfunction useFormField(initialVal = '') {\r\n  const [val, setVal] = React.useState(initialVal);\r\n  const [isValid, setValid] = React.useState(true);\r\n\r\n  function onChange(e) {\r\n    setVal(e.target.value);\r\n\r\n    if (!e.target.value) {\r\n      setValid(false);\r\n    } else if (!isValid) setValid(true);\r\n  }\r\n\r\n  return [val, onChange, isValid];\r\n}\r\n\r\nexport default useFormField;\r\n\r\n```\r\n\r\n**As great as custom hooks are in abstracting away re-usable logic in our code, they do have one limitation. Even though they are just JavaScript functions they will work only inside React components. You cannot just invoke them and write tests against what a hook returns. You have to wrap them inside a React component and test the values that it returns.**\r\n\r\n- custom hooks cannot be tested like JavaScript functions\r\n- custom hooks should be wrapped inside a React component to test its behaviour\r\n\r\nThanks to the composibility of hooks, we could pass a hook as a prop to a component and everything will work exactly as how it's supposed to work. We can write a wrapper component to render and test our hook.\r\n\r\n```\r\n/* useFormField.test.js */\r\n\r\nfunction HookWrapper(props) {\r\n  const hook = props.hook ? props.hook() : undefined;\r\n  return <div hook={hook} />;\r\n}\r\n\r\n```\r\n\r\nNow we can access the hook like a JavaScript object and test its behaviour.\r\n\r\n```\r\n/* useFormField.test.js */\r\n\r\nimport React from 'react';\r\nimport { shallow } from 'enzyme';\r\nimport useFormField from './useFormField';\r\n\r\nfunction HookWrapper(props) {\r\n  const hook = props.hook ? props.hook() : undefined;\r\n  return <div hook={hook} />;\r\n}\r\n\r\nit('should set init value', () => {\r\n  let wrapper = shallow(<HookWrapper hook={() => useFormField('')} />);\r\n\r\n  let { hook } = wrapper.find('div').props();\r\n  let [val, onChange, isValid] = hook;\r\n  expect(val).toEqual('');\r\n\r\n  wrapper = shallow(<HookWrapper hook={() => useFormField('marco')} />);\r\n\r\n  // destructuring objects - {} should be inside brackets - () to avoid syntax error\r\n  ({ hook } = wrapper.find('div').props());\r\n  [val, onChange, isValid] = hook;\r\n  expect(val).toEqual('marco');\r\n});\r\n\r\n```\r\n\r\nThe full test suite for `useFormField` custom hook will look like this.\r\n\r\n```\r\n/* useFormField.test.js */\r\n\r\nimport React from 'react';\r\nimport { shallow } from 'enzyme';\r\nimport useFormField from './useFormField';\r\n\r\nfunction HookWrapper(props) {\r\n  const hook = props.hook ? props.hook() : undefined;\r\n  return <div hook={hook} />;\r\n}\r\n\r\ndescribe('useFormField', () => {\r\n  it('should render', () => {\r\n    let wrapper = shallow(<HookWrapper />);\r\n\r\n    expect(wrapper.exists()).toBeTruthy();\r\n  });\r\n\r\n  it('should set init value', () => {\r\n    let wrapper = shallow(<HookWrapper hook={() => useFormField('')} />);\r\n\r\n    let { hook } = wrapper.find('div').props();\r\n    let [val, onChange, isValid] = hook;\r\n    expect(val).toEqual('');\r\n\r\n    wrapper = shallow(<HookWrapper hook={() => useFormField('marco')} />);\r\n\r\n    // destructuring objects - {} should be inside brackets - () to avoid syntax error\r\n    ({ hook } = wrapper.find('div').props());\r\n    [val, onChange, isValid] = hook;\r\n    expect(val).toEqual('marco');\r\n  });\r\n\r\n  it('should set the right val value', () => {\r\n    let wrapper = shallow(<HookWrapper hook={() => useFormField('marco')} />);\r\n\r\n    let { hook } = wrapper.find('div').props();\r\n    let [val, onChange, isValid] = hook;\r\n    expect(val).toEqual('marco');\r\n\r\n    onChange({ target: { value: 'polo' } });\r\n\r\n    ({ hook } = wrapper.find('div').props());\r\n    [val, onChange, isValid] = hook;\r\n    expect(val).toEqual('polo');\r\n  });\r\n\r\n  it('should set the right isValid value', () => {\r\n    let wrapper = shallow(<HookWrapper hook={() => useFormField('marco')} />);\r\n\r\n    let { hook } = wrapper.find('div').props();\r\n    let [val, onChange, isValid] = hook;\r\n    expect(val).toEqual('marco');\r\n    expect(isValid).toEqual(true);\r\n\r\n    onChange({ target: { value: 'polo' } });\r\n\r\n    ({ hook } = wrapper.find('div').props());\r\n    [val, onChange, isValid] = hook;\r\n    expect(val).toEqual('polo');\r\n    expect(isValid).toEqual(true);\r\n\r\n    onChange({ target: { value: '' } });\r\n\r\n    ({ hook } = wrapper.find('div').props());\r\n    [val, onChange, isValid] = hook;\r\n    expect(val).toEqual('');\r\n    expect(isValid).toEqual(false);\r\n  });\r\n});\r\n\r\n```\r\n\r\nRendering the custom hook and accessing it as a prop should give us full access to its return values.\r\n\r\nIf you're using `useEffect` hook in your custom hook, make sure you wrap the `shallow` or `mount` call with [ReactTestUtils.act()](https://reactjs.org/docs/test-utils.html#act) to have the effects flushed out before assertions. Enzyme might support this internally soon but for now, this is required. More info on this here - [hooks-faq](https://reactjs.org/docs/hooks-faq.html#how-to-test-components-that-use-hooks).\r\n\r\n```\r\nact(() => {\r\n  wrapper = shallow(<HookWrapper />);\r\n});\r\n\r\n```\r\n\r\nAll code snippets in this post can be found in the repo - [testing-hooks](https://github.com/flexdinesh/testing-hooks) with a working example.\r\n\r\nHappy testing! ðŸŽ‰\r\n","data":{"draft":false,"image":"/assets/images/blog/3.jpg","title":"React Hooks - Test custom hooks with Enzyme","tags":["react","redux"],"date":"2018-07-23T00:00:00.000Z"},"slug":"3-react-hooks-test-custom-hooks-with-enzyme"},{"content":"\r\nSeparate authentication from your Components with a dedicated authentication component.\r\n\r\nWhen writing [React](https://facebook.github.io/react/) applications with [Redux](https://github.com/reactjs/redux) and [react-router-redux](https://github.com/reactjs/react-router-redux) some routes in your application may require an authenticated user and others not. To separate the authentication concern we use a specific container that checks for the authentication and before rendering the child. If the authentication fails then you can respond by display an error or more likely redirect to login.\r\n\r\n## Route\r\n\r\nTo simplify the main render method we use a function to wrap the child in an `AuthenticatedComponent`, so it is clear in your main render method which parts of your application are protected.\r\n\r\n```\r\nReactDOM.render(\r\n  <Provider store={store}>\r\n    <Router history={history}>\r\n      <Route path=\"/\" component={AppParent}>\r\n        <Route path=\"login\" component={LoginContainer}/>\r\n        <Route path=\"logout\" component={LogoutContainer}/>\r\n        <Route path=\"about\" component={AboutPage}/>\r\n        <Route path=\"help\" component={HelpPage}/>\r\n        <Route path=\"user\" component={requireAuth(UserContainer)}/>\r\n        <Route path=\"admin\" component={requireAuth(AdminContainer)}/>\r\n        <Route path=\"main\" component={requireAuth(MainContainer)}>\r\n          <Route path=\"one\" component={FirstPage}/>\r\n          <Route path=\"two\" component={SecondPage}/>\r\n        </Route>\r\n      </Route>\r\n    </Router>\r\n  </Provider>,\r\n  document.getElementById('app')\r\n)\r\n```\r\n\r\n## Authenticated Component\r\n\r\nWe then implement the `requireAuth` function as follows. You may need to change the detail of the auth check depending on your authentication actions and you can make the `authFailed` function do whatever you like, in this example we redirect to login with the path so we can redirect back after a successful login.\r\n\r\n```\r\nimport React, { Component, PropTypes } from 'react'\r\nimport { connect } from 'react-redux'\r\nimport { push } from 'react-router-redux'\r\n\r\nexport function requireAuth(ChildComponent) {\r\n\r\n  class AuthenticatedComponent extends Component {\r\n\r\n    componentWillMount() {\r\n      this.checkAuth(this.props.isAuthenticated);\r\n    }\r\n\r\n    componentWillReceiveProps(nextProps) {\r\n      this.checkAuth(nextProps.isAuthenticated);\r\n    }\r\n\r\n    checkAuth(isAuthenticated) {\r\n      if (!isAuthenticated) {\r\n        this.props.authFailed();\r\n      }\r\n    }\r\n\r\n    render() {\r\n      return (\r\n        <div>\r\n         { this.props.isAuthenticated === true ?\r\n           <ChildComponent { ...this.props } /> : null }\r\n        </div>\r\n      )\r\n\r\n    }\r\n  }\r\n\r\n  const mapStateToProps = (state) => ({\r\n    auth: state.auth,\r\n    isAuthenticated: state.auth.login.isAuthenticated,\r\n  });\r\n\r\n  const mapDispatchToProps = (dispatch, ownProps) => {\r\n    return {\r\n      authFailed: () => {\r\n        let location = ownProps.location\r\n        let redirect = encodeURIComponent(location.pathname + location.search)\r\n        dispatch(push(`/login?next=${redirect}`))\r\n      },\r\n    }\r\n  }\r\n\r\n  return connect(mapStateToProps, mapDispatchToProps)(AuthenticatedComponent);\r\n\r\n}\r\n\r\n```\r\n\r\nThe auth details can be useful for the child components, say to show the username but not all children are likely to need it. A good way to do this is to make it a context object for the children. This can be done by adding the following to the class:\r\n\r\n```\r\nclass AuthenticatedComponent extends Component {\r\n\r\n  \\\\...\r\n\r\n  static childContextTypes = {\r\n    auth: PropTypes.object.isRequired\r\n  }\r\n\r\n  getChildContext() {\r\n    return {\r\n      auth: this.props.auth\r\n    }\r\n  }\r\n\r\n  \\\\...\r\n}\r\n```\r\n","data":{"draft":false,"image":"/assets/images/blog/1.webp","title":"Authenticated Container for React Router and Redux","tags":["react","redux"],"date":"2018-07-14T00:00:00.000Z"},"slug":"1-authenticated-container-react-router-redux"}]}