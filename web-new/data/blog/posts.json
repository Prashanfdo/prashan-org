{"data":[{"content":"\nHere we will check out how to deploy smart contracts to the Polygon (Matic) Mumbai test network. We'll cover some of the possible errors which might occur during the deployment.\n\n### 1. MetaMask setup.\n\nTo deploy the smart contracts on Matic you first have to create a Matic network in MetaMask wallet.  \n`Settings -> Networks -> Add network -> Save`  \n![MetaMask Setup](/assets/images/blog/15.1.png)  \nTo get test Matic for deployment and testing,  \n`go to ->` [Matic Faucet](https://faucet.matic.network/) `-> Select Mumbai -> Paste wallet address -> Submit`  \nDone! check your wallet, you'll see some Matic there.\n\n### 2. truffle-config\n\n- `truffle-config.js` for Mac users\n- `truffle.js` for Windows users The truffle-config file is an important file to understand. In this file, we must configure the path to the DTube Solidity file (smart contract), the contract ABI, and define the available **networks**.\n\n```\nconst HDWalletProvider = require(\"@truffle/hdwallet-provider\")\nrequire('dotenv').config(); // Load .env file\n\nmodule.exports = {\n  networks: {\n   // For Ganache, your personal blockchain\n   development: {\n      host: \"127.0.0.1\",     // Localhost (default: none)\n      port: 8545,            // Standard Ethereum port\n      network_id: \"*\",       // Any network (default: none)\n    },\n  },\n  contracts_directory: './src/contracts/',\n  contracts_build_directory: './src/abis/',\n  compilers: {\n    solc: {\n      optimizer: {\n        enabled: true,\n        runs: 200\n      }\n    }\n  }\n}\n\n```\n\nEnsure you create an `.env` file in the project root directory (`~/DTube/.env`) and paste into it the Secret Recovery Phrase (12 words) of your preferably newly generated and testnet-only MetaMask wallet with the variable name MNEMONIC. This will be loaded by truffle at runtime, and the environment variable can then be accessed with `process.env.MNEMONIC`.\n\n```\nMNEMONIC= 12 secret words here..\n```\n\nNow, let's add `matic` network in our truffle-config file which will contain our environment variable MNEMONIC and RPC URL.\n\n```\nmatic: {\n  provider: () => new HDWalletProvider(process.env.MNEMONIC,\n  `https://rpc-mumbai.matic.today`),\n  network_id: 80001,\n  confirmations: 2,\n  timeoutBlocks: 200,\n  skipDryRun: true,\n  gas: 6000000,\n  gasPrice: 10000000000,\n},\n\n```\n\nYou can set the gas price and gas limits for faster transactions as shown in the above code block.\n\n### 3. Deploy Smart Contracts\n\nCommand: `truffle migrate --network matic`  \nIf you're deploying it second time then deploy with this command just to **reset** and avoid JSON errors.  \nCommand: `truffle migrate --network matic --reset`  \nIf everything worked fine, you'll see something like this:\n\n```\n2_deploy_contracts.js\n=====================\n\n   Replacing 'MyContract'\n   ------------------\n   > transaction hash:    0x1c94d095a2f629521344885910e6a01076188fa815a310765679b05abc09a250\n   > Blocks: 5            Seconds: 5\n   > contract address:    0xbFa33D565Fcb81a9CE8e7a35B61b12B04220A8EB\n   > block number:        2371252\n   > block timestamp:     1578238698\n   > account:             0x9fB29AAc15b9A4B7F17c3385939b007540f4d791\n   > balance:             79.409358061899298312\n   > gas used:            1896986\n   > gas price:           0 gwei\n   > value sent:          0 ETH\n   > total cost:          0 ETH\n\n   Pausing for 2 confirmations...\n   ------------------------------\n   > confirmation number: 5 (block: 2371262)\ninitialised!\n\n   > Saving migration to chain.\n   > Saving artifacts\n   -------------------------------------\n   > Total cost:                   0 ETH\n\n\nSummary\n=======\n> Total deployments:   2\n> Final cost:          0 ETH\n\n```\n\n_Code snippet from matic truffle docs._\n\n### 4. Dealing with different errors\n\nIf you get any of these errors then follow these steps\n\n#### Error:\n\n```\nError: PollingBlockTracker - encountered an error while attempting to update latest block:\n\n```\n\n#### Fix_1:\n\nChange `https://rpc-mumbai.matic.today` by using [Infura custom RPC](https://infura.io/)  \n`infura -> Create new project -> Settings -> Endpoints -> Polygon Mumbai`\n\n```\n    matic: {\n      provider: () => new HDWalletProvider(process.env.MNEMONIC,\n      `https://polygon-mumbai.infura.io/v3/process.env.PROJECT_ID`),\n      network_id: 80001,\n      confirmations: 2,\n      timeoutBlocks: 200,\n      skipDryRun: true,\n    },\n  },\n\n```\n\nPaste your PROJECT_ID there from .env file.  \n`truffle migrate --network matic --reset`\n\nIf still dealing with error, try this 2nd fix.\n\n#### Fix_2:\n\nChange `https://rpc-mumbai.matic.today` by using [Matic custom RPC](https://rpc.maticvigil.com/)\n\n```\n    matic: {\n      provider: () => new HDWalletProvider(process.env.MNEMONIC,\n      `https://rpc-mumbai.maticvigil.com/v1/process.env.PROJECT_ID`),\n      network_id: 80001,\n      confirmations: 2,\n      timeoutBlocks: 200,\n      skipDryRun: true,\n    },\n  },\n\n```\n\nPaste your PROJECT_ID there from .env file.  \n`truffle migrate --network matic --reset`\n\n#### Error:\n\n```\n*** Deployment Failed ***\n\n\"Migrations\" -- only replay-protected (EIP-155) transactions allowed over RPC.\n\n```\n\n#### Fix:\n\n`npm install @truffle/hdwallet-provider@1.4.0`  \nTruffle hdwallet-provider version 1.4.0 will fix this error.\n\n#### Error:\n\n```\nError:  *** Deployment Failed ***\n\n\"Migrations\" -- Transaction was not mined within 750 seconds, please make sure your transaction was properly sent. Be aware that it might still be mined!.\n\n```\n\n#### Fix:\n\n```\n    matic: {\n      provider: () => new HDWalletProvider(process.env.MNEMONIC,\n      `https://rpc-mumbai.maticvigil.com/v1/process.env.PROJECT_ID`),\n      network_id: 80001,\n      confirmations: 2,\n      timeoutBlocks: 200,\n      skipDryRun: true,\n      networkCheckTimeout: 100000,\n    },\n  },\n\n```\n\nJust add `networkCheckTimeout: 100000`\n","data":{"draft":false,"image":"/assets/images/blog/15.jpg","title":"Deploy Smart Contracts on Polygon (Matic) Network and Error Handling","tags":["ethereum"," smart-contract","matic"],"date":"2022-02-04T00:00:00.000Z"},"slug":"15-deploy-smart-contracts-on-polygon-matic-network-and-error-handling"},{"content":"\r\nThe `selfdestruct(address)` function, removes all bytecode from the contract address and sends all ether stored to the specified address. If this specified address is also a contract, no functions (including the fallback) get called.\r\n\r\nIn other words, an attacker can create a contract with a `selfdestruct()` function, send ether to it, call `selfdestruct(target)` and force ether to be sent to a target.\r\n\r\nLet's see how this attack can look like. We create a simple smart contract. Note: I created this contract based on [Solidity by example](https://solidity-by-example.org/hacks/self-destruct/).\r\n\r\n```\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.10;\r\n\r\n\r\n\r\ncontract EtherGame {\r\n    uint public targetAmount = 5 ether;\r\n    address public winner;\r\n\r\n    function play() public payable {\r\n        require(msg.value == 1 ether, \"You can only send 1 Ether\");\r\n\r\n        uint balance = address(this).balance;\r\n        require(balance <= targetAmount, \"Game is over\");\r\n\r\n        if (balance == targetAmount) {\r\n            winner = msg.sender;\r\n        }\r\n    }\r\n\r\n    function claimReward() public {\r\n        require(msg.sender == winner, \"Not winner\");\r\n\r\n        (bool sent, ) = msg.sender.call{value: address(this).balance}(\"\");\r\n        require(sent, \"Failed to send Ether\");\r\n    }\r\n}\r\n\r\ncontract Attack {\r\n    EtherGame etherGame;\r\n\r\n    constructor(EtherGame _etherGame) {\r\n        etherGame = EtherGame(_etherGame);\r\n    }\r\n\r\n    function attack() public payable {\r\n\r\n        address payable addr = payable(address(etherGame));\r\n        selfdestruct(addr);\r\n    }\r\n}\r\n```\r\n\r\nThis contract represents a simple game whereby players send 1 ether to the contract hoping to be the one that reaches the threshold equal 5 eth. When the 5 eth will be reached the game is ended and the first player who reaches the milestone may claim a reward.\r\n\r\nIn this case, an attacker can e.g. send to the contract 5 eth or any other value that push the contract's balance above the threhshold. This would lock all rewards in the contract forever.\r\n\r\nThis is because our if statement in the function `play()` checks if the winner's balance is equal 5 eth.\r\n\r\n### Preventative Techniques\r\n\r\nThis vulnerability arises from the misuse of `this.balance`. Your contract should avoid being dependent on the exact values of the balance of the contract because it can be artificially manipulated.\r\n\r\nIf exact values of deposited ether are required, a self-defined variable should be used that gets incremented in payable functions, to safely track the deposited ether. This can prevent your contract to be influenced by the forced ether sent via a `selfdestruct()` call.\r\n\r\nLet's see how the safe version of the contract looks like.\r\n\r\n```\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.10;\r\n\r\n\r\n\r\ncontract EtherGame {\r\n    uint public targetAmount = 5 ether;\r\n    address public winner;\r\n    uint public balance;\r\n\r\n    function play() public payable {\r\n        require(msg.value == 1 ether, \"You can only send 1 Ether\");\r\n\r\n        uint balance += msg.value;\r\n        require(balance <= targetAmount, \"Game is over\");\r\n\r\n        if (balance == targetAmount) {\r\n            winner = msg.sender;\r\n        }\r\n    }\r\n\r\n    function claimReward() public {\r\n        require(msg.sender == winner, \"Not winner\");\r\n\r\n        (bool sent, ) = msg.sender.call{value: address(this).balance}(\"\");\r\n        require(sent, \"Failed to send Ether\");\r\n    }\r\n}\r\n\r\ncontract Attack {\r\n    EtherGame etherGame;\r\n\r\n    constructor(EtherGame _etherGame) {\r\n        etherGame = EtherGame(_etherGame);\r\n    }\r\n\r\n    function attack() public payable {\r\n\r\n        address payable addr = payable(address(etherGame));\r\n        selfdestruct(addr);\r\n    }\r\n}\r\n```\r\n\r\nHere, we no longer have any reference to `this.balance`. Instead, we have created a new variable, `balance` which keeps tracking of the current amount of eth.\r\n","data":{"draft":false,"image":"/assets/images/blog/13.jpg","title":"Secure Smart Contracts from Self Destruct","tags":["security"," smart-contract","blockchain","solidity"],"date":"2021-12-22T00:00:00.000Z"},"slug":"14-secure-smart-contracts-from-self-destruct"},{"content":"\r\nAs you might know testing is very important, especially when working with smart contract and blockchain, as anything in the blockchain is immutable.\r\n\r\n### Setup\r\n\r\nYou can **install Truffle**, an open source tool suite that will allow you to develop, test and deploy your contract.  \r\nUse `npm install -g truffle` and you’re all set.\r\n\r\nThen, **download Ganache** from the [Truffle website](https://trufflesuite.com/ganache/). This tool will allow you to setup a personal Ethereum blockchain that you can use to run and test your contract.\r\n\r\nFinally, you can fire up any IDE on the project directory. I would recommend VSCode with the [Solidity plugin](https://github.com/juanfranblanco/vscode-solidity).\r\n\r\n### Time to code\r\n\r\nAlright, the first thing to do once you’ve downloaded everything is to init a project. To do so, create a new directory and let truffle do his thing:\r\n\r\n```\r\ntruffle init\r\n```\r\n\r\nThis will create a `test` Directory and `truffle-config.js` file.\r\nWe'll be using the below example contract for testing.\r\n\r\n```\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract Fundraiser {\r\n   address public owner;\r\n   address[] public backers;\r\n\r\n   constructor() {\r\n       owner = msg.sender;\r\n   }\r\n\r\n   function sendMoney() public payable {\r\n       require(msg.value > 0, \"No Ether were sent.\");\r\n       backers.push(msg.sender);\r\n   }\r\n\r\n   function getBalance() public view returns (uint256) {\r\n       return address(this).balance;\r\n   }\r\n\r\n   function endFundraising() public {\r\n       require(msg.sender == owner, \"Only the owner is allowed to end the fundraising.\");\r\n       payable(owner).transfer(address(this).balance);\r\n   }\r\n}\r\n```\r\n\r\n### Creating a test file\r\n\r\nWe’ll start by creating a new file called `fundraiser.js`. We are going to write our test in Javascript. If you are familiar with it, Truffle uses the [Mocha testing framework](https://mochajs.org/), with a few differences, it uses `contract()` instead of `describe()`.\r\n\r\nThat `contract` method is just used to logically group the tests by contract. Before executing your tests, the function make sure the contract is redeployed to the running environment.\r\n\r\nHere, I’m assuming you have Ganache installed and running.\r\n\r\nSo in this empty JavaScript file, we will first get our compiled contract and call the `contract` method to start writing test cases:\r\n\r\n```\r\nconst Fundraiser = artifacts.require(\"./Fundraiser.sol\");\r\n\r\ncontract(\"Fundraiser\", (accounts) => {\r\n\r\n});\r\n```\r\n\r\nThe `contract` method has two parameter, the first one would be the name of the contract and the second one is a function that gives you a parameter with a list of account that your environment provided for testing. That’s in that function that we will describe out test cases with Mocha’s `it` function.\r\n\r\nJust like contract, two parameters, a description of the test and the actual test.  \r\nWe can describe as many tests as we need.\r\n\r\n```\r\nconst Fundraiser = artifacts.require(\"./Fundraiser.sol\");\r\n\r\ncontract(\"Fundraiser\", (accounts) => {\r\n    it(\"some test\", async () => {\r\n        // ...\r\n    });\r\n    it(\"some other test\", async () => {\r\n        // ...\r\n    });\r\n});\r\n```\r\n\r\n## Interacting with our contract\r\n\r\nWhile testing a contract you will need to interact with it. The first thing you would want is to access an instance. From the artifact, you can call the `.deployed()`.\r\n\r\n```\r\nconst contract = await Fundraiser.deployed();\r\n\r\n```\r\n\r\nTo access a public variable from your contract, we will use the `call()` function.\r\n\r\n```\r\nconst owner = await contract.owner.call();\r\n\r\n```\r\n\r\nFinally, to call a public function just call the function like you would to on any object.\r\n\r\n```\r\nlet balance = await contract.getBalance();\r\n\r\n```\r\n\r\nTo add a value or specify the caller’s address, add an optional object :\r\n\r\n```\r\nawait contract.sendMoney({from: '0x0...', value: 1});\r\n\r\n```\r\n\r\nNote: value is in Gwei (1 Gwei = 0,00000001 Ether), to send Ether, just multiply the value by 10 to the power of 18 (`10**18` in JavaScript).  \r\nYou can also the gas and some data as parameter. More on the [Truffle documentation](https://trufflesuite.com/docs/truffle/getting-started/interacting-with-your-contracts.html).\r\n\r\nNow you should have anything needed to test our contract.\r\n\r\n## Writing some tests\r\n\r\nThe first one will verify if the `backers` array get properly populated after a backer would have sent some Ether.\r\n\r\n```\r\n    it(\"check the participants array after participation\", async () => {\r\n        // Get the first account\r\n        let account = accounts[0];\r\n        // Retreive the deployed contract\r\n        const contract = await Fundraiser.deployed();\r\n        // Make the account send 14 gwei\r\n        await contract.sendMoney({from: account, value: 14});\r\n        // Get the particpant at index 0\r\n        let backer = await contract.backers.call(0);\r\n        // Check if that participant is the same as the addess we used\r\n        assert.equal(backer, account);\r\n    });\r\n\r\n```\r\n\r\nWe will write another test to check the balance increase.\r\n\r\n```\r\n    it(\"check the balance increase\", async () => {\r\n        // Get the first account\r\n        let account = accounts[0];\r\n        // Retreive the deployed contract\r\n        const contract = await Fundraiser.deployed();\r\n        // Get the balance before the operation\r\n        let balanceBefore = await contract.getBalance();\r\n        // Send 1 gwei\r\n        await contract.sendMoney({from: account, value: 1});\r\n        // Get the balance after the gwei was sent\r\n        let balanceAfter = await contract.getBalance();\r\n        // Check if the balance after is equal to the balance before plus 1\r\n        assert.equal(balanceAfter.toString(), parseInt(balanceBefore.toString())+1);\r\n    });\r\n\r\n```\r\n\r\nOne last test to check the end of the fundraising.\r\n\r\n```\r\n    it(\"check the balance after the fundraising ends\", async () => {\r\n        // Retreive the deployed contract\r\n        const contract = await Fundraiser.deployed();\r\n        // Get the contract owner by accessing the owner attribute\r\n        const contractOwner = contract.owner.call();\r\n        let contractsBalanceBefore = await contract.getBalance();\r\n        let ownersBalanceBefore = await web3.eth.getBalance(contractOwner);\r\n        // End the fund raising\r\n        await contract.endFundraising({from: contractOwner});\r\n        let contractsBalanceAfter = await contract.getBalance();\r\n        let ownersBalanceAfter = await web3.eth.getBalance(contractOwner);\r\n        // Check if the contract balance is now zero\r\n        assert.equal(contractsBalanceAfter, 0);\r\n        // Check if the owner account received the contract's balance\r\n        assert.equal(ownersBalanceBefore >= ownersBalanceAfter+contractsBalanceBefore, true);\r\n    });\r\n\r\n```\r\n\r\nLooks like we now have a decent code coverage for our contract.\r\n\r\nWe can just run the tests with the command `truffle test`.\r\n\r\nDont hesitate to check out the amazing documentation from the [truffle website](https://trufflesuite.com/docs/truffle/testing/writing-tests-in-javascript.html). You can also check the [Mocha documentation](https://mochajs.org/).\r\n","data":{"draft":false,"image":"/assets/images/blog/14.jpg","title":"Truffle for Smart Contract Testing","tags":["ethereum"," smart-contract","solidity"],"date":"2021-12-16T00:00:00.000Z"},"slug":"13-truffle-for-smart-contract-testing"},{"content":"\r\nReentrancy attack is one of the most destructive attacks in Solidity smart contract. A reentrancy attack occurs when a function makes an external call to another untrusted contract. Then the untrusted contract makes a recursive call back to the original function in an attempt to drain funds.\r\n\r\nWhen the contract fails to update its state prior to sending funds the attacker can continuously call the withdraw function to drain the contract’s funds. A famous real-world Reentrancy attack is the DAO attack which caused a loss of 60 million US dollars\r\n\r\n### How does reentrancy attack work?\r\n\r\nA reentrancy attack involves two smart contracts. A vulnerable contract and an untrusted attackers contract.\r\n\r\n![Reentrancy Attack in Solidity Smart Contract](/assets/images/blog/12.1.jpg)\r\n\r\n### Reentrancy attack scenario\r\n\r\n1.  Vulnerable smart contract have 10 eth.\r\n2.  An attacker store 1 eth using deposit function.\r\n3.  An attacker calls the withdraw function and points to a malicious contract as a recipient.\r\n4.  Now withdraw function will verify if it can be executed:\r\n\r\n- Does the attacker have 1 eth on their balance? Yes – because of their deposit.\r\n- Transfer 1 eth to a malicious contract. (Note: attacker balance has NOT been updated yet)\r\n- Fallback function on received eth calls withdraw function again.\r\n\r\n5.  Now withdraw function will verify if it can be executed:\r\n\r\n- Does the attacker have 1 eth on their balance? Yes – because the balance has not been updated.\r\n- Transfer 1 eth to a malicious contract.\r\n- and again until the attacker will drain all the funds stored on the contract\r\n\r\nBelow is the contract which contains the reentrancy vulnerability\r\n\r\n```\r\ncontract DepositFunds {\r\n    mapping(address => uint) public balances;\r\n\r\n    function deposit() public payable {\r\n        balances[msg.sender] += msg.value;\r\n    }\r\n\r\n    function withdraw() public {\r\n        uint bal = balances[msg.sender];\r\n        require(bal > 0);\r\n\r\n        (bool sent, ) = msg.sender.call{value: bal}(\"\");\r\n        require(sent, \"Failed to send Ether\");\r\n\r\n        balances[msg.sender] = 0;\r\n    }\r\n}\r\n```\r\n\r\nThe vulnerability comes where we send the user their requested amount of ether. In this case, the attacker calls withdraw() function. Since his balance has not yet been set to 0, he is able to transfer the tokens even though he already received tokens.\r\n\r\nNow, let's consider a malicious attacker creating the following contract\r\n\r\n```\r\ncontract Attack {\r\n    DepositFunds public depositFunds;\r\n\r\n    constructor(address _depositFundsAddress) {\r\n        depositFunds = DepositFunds(_depositFundsAddress);\r\n    }\r\n\r\n    // Fallback is called when DepositFunds sends Ether to this contract.\r\n    fallback() external payable {\r\n        if (address(depositFunds).balance >= 1 ether) {\r\n            depositFunds.withdraw();\r\n        }\r\n    }\r\n\r\n    function attack() external payable {\r\n        require(msg.value >= 1 ether);\r\n        depositFunds.deposit{value: 1 ether}();\r\n        depositFunds.withdraw();\r\n    }\r\n\r\n\r\n}\r\n```\r\n\r\nThe attack function calls the withdraw function in the victim’s contract. When the token is received the fallback function calls back the withdraw function. Since the check is passed contract sends the token to the attacker which triggers the fallback function.\r\n\r\n### How to protect smart contract against reentrancy attack?\r\n\r\nTo prevent a reentrancy attack in a Solidity smart contract you should:\r\n\r\n- Ensure all state changes happen before calling external contracts, i.e. update balances or code internally before calling external code\r\n- Use function modifiers that prevent re-entrancy\r\n\r\n#### Modifier to prevent a reentrancy attack\r\n\r\n```\r\ncontract ReEntrancyGuard {\r\n    bool internal locked;\r\n\r\n    modifier noReentrant() {\r\n        require(!locked, \"No re-entrancy\");\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n}\r\n```\r\n","data":{"draft":false,"image":"/assets/images/blog/12.jpg","title":"Secure Smart Contracts from Reentrancy attack","tags":["security"," web3"," smart-contracts","blockchain","solidity"],"date":"2021-12-06T00:00:00.000Z"},"slug":"12-secure-smart-contracts-from-reentrancy-attack"},{"content":"\r\nThis is going to be a super simple tutorial that will cover how to check if an Ethereum address is indeed a valid address.\r\n\r\nThis tutorial starts from a newly created [Next JS](https://nextjs.org/docs/api-reference/create-next-app) project. Also, make sure to install the [web3 library](https://www.npmjs.com/package/web3).\r\n\r\nI’ll paste the entire file below and talk about it below the code. So, replace your _index.js_ file with this for a minimal example:\r\n\r\n```\r\nimport { useState } from 'react'\r\nimport Web3 from 'web3'\r\nimport styles from '../styles/Home.module.css'\r\n\r\nexport default function Home() {\r\n  const [address, setAddress] = useState('')\r\n\r\n  const isValidAddress = (adr) => {\r\n    try {\r\n      const web3 = new Web3()\r\n      web3.utils.toChecksumAddress(adr)\r\n      return true\r\n    } catch (e) {\r\n      return false\r\n    }\r\n  }\r\n\r\n  return (\r\n    <div className={styles.container}>\r\n      <input onChange={(e) => setAddress(e.target.value)} value={address} />\r\n      {isValidAddress(address) ? <div>Address is valid</div> : <div>Address is not valid</div>}\r\n    </div>\r\n  )\r\n}\r\n```\r\n\r\nThe code here has an input that can be typed in. On change of the input, it sets the `address` variable.\r\n\r\nThe `isValidAddress` method checks if the address is valid and then displays that in text.\r\n\r\nThis method is the valuable piece to this tutorial that most people are probably looking for. It just creates a `web3` object and calls a utility method. If `toChecksumAddress` passes without error then it is a valid address. Otherwise, the address is not valid.\r\n","data":{"draft":false,"image":"/assets/images/blog/11.jpg","title":"ETH Address validation using Web3.js","tags":["web3"],"date":"2021-09-21T00:00:00.000Z"},"slug":"11-eth-address-validation-using-web3-js"},{"content":"\r\nTailwind CSS is a utility-fast CSS framework for building custom UI in a faster & easier way. Tailwind CSS is highly customizable low-level CSS framework.\r\n\r\n## Steps to add Tailwind CSS to a Next.js application.\r\n\r\n## 1. Install Tailwind dependencies.\r\n\r\nif using `yarn`\r\n\r\n```\r\nyarn add -D tailwindcss@latest postcss@latest autoprefixer@latest\r\n```\r\n\r\nif using `npm`\r\n\r\n```\r\nnpm install -D tailwindcss@latest postcss@latest autoprefixer@latest\r\n```\r\n\r\n## 2. Create the configuration files\r\n\r\nif using `yarn`\r\n\r\n```\r\nyarn tailwindcss init -p\r\n```\r\n\r\nif using `npx`\r\n\r\n```\r\nnpx tailwindcss init -p\r\n```\r\n\r\nNow, this command will create a minimal `tailwind.config.js` file at the root directory.\r\n\r\n```\r\n// tailwind.config.js\r\nmodule.exports = {\r\n purge: [],\r\n darkMode: false, // or 'media' or 'class'\r\n theme: {\r\n extend: {},\r\n },\r\n variants: {\r\n extend: {},\r\n },\r\n plugins: [],\r\n}\r\n```\r\n\r\nThat also creates a `postcss.config.js` file -\r\n\r\n```\r\nmodule.exports = {\r\n plugins: {\r\n tailwindcss: {},\r\n autoprefixer: {},\r\n },\r\n}\r\n```\r\n\r\n## 3. Configure the Tailwind\r\n\r\nIn `tailwind.config.js` file, configure the `purge` option with the paths to all the pages & components so Tailwind can tree-shake unused styles in production builds.\r\n\r\n```\r\npurge: ['./pages/**/*.{js,ts,jsx,tsx}', './components/**/*.{js,ts,jsx,tsx}']\r\n```\r\n\r\nAgain if you want to use `dark mode`, change the option -\r\n\r\n```\r\ndarkmode: 'class';\r\n```\r\n\r\n## 4. Include Tailwind in CSS\r\n\r\nopen the `./styles/global.css` file and the following lines of code -\r\n\r\n```\r\n@tailwind base;\r\n@tailwind components;\r\n@tailwind utilities;\r\n```\r\n\r\n## 5. Add Tailwind CSS IntelliSense to VS Code\r\n\r\nFor the autocomplete features for Tailwind CSS classes in VS Code, Install the plugin — [Tailwind CSS IntelliSense](https://marketplace.visualstudio.com/items?itemName=bradlc.vscode-tailwindcss)\r\n","data":{"draft":false,"image":"/assets/images/blog/9.jpg","title":"Add Tailwind CSS to Next.js","tags":["react"],"date":"2021-09-05T00:00:00.000Z"},"slug":"10-add-tailwind-css-to-next-js"},{"content":"\r\nIn Nextjs, a route (page on your website) is created by simply creating a React component inside the pages folder. If for example you create a dashboard.tsx file inside the pages folder then the component inside this file will be rendered for a user visiting _www.example.com/dashboard._\r\n\r\nIn order to make a route only accessible to authenticated users, we need to find a way to be able to check whether the user is authenticated when they try to access the page.\r\n\r\nImagine having a room with all your really important private items and secrets inside, you don’t want anyone to be able to see what’s inside unless you have explicitly allowed them to right? Right!\r\n\r\nImagine that people started entering your room, and it’s only when they get inside that you can ask the ones that are not meant to be there to leave. This is what would happen if you check if a user is authenticated directly in the route component itself.\r\n\r\nNow imagine we could have a reception area in front of this room, that would only let people into the room that are actually allowed in. This sounds like a better plan doesn’t it? We can achieve this by wrapping the page component in an authentication component.\r\n\r\n**Prerequisites:**\r\n\r\nPlease setup the two following projects to be able to easily follow this tutorial.\r\n\r\n- Nextjs project setup with Typescript: [Nextjs docs](https://nextjs.org/docs/getting-started)\r\n- Basic Hello World ExpressJS app: [Express docs](https://expressjs.com/en/starter/installing.html)\r\n\r\n## Create a simple express API to test the frontend\r\n\r\nLet’s jump to the Backend for a few minutes!\r\n\r\nWe are not going to go into how to setup an express server in node as this is a prerequisite for this tutorial, but you can copy this code into the index.js file of your express app in order to setup a simple GET endpoint to allow us to test the frontend functionality.\r\n\r\n```\r\n**_index.js_**const express = require('express');\r\nconst app = express();/*\r\n  Do not use this as authentication on the backend. This is only a simple setup to test the secure route on the frontend.\r\nFor more information on JSON web tokens please checkout this link [https://github.com/auth0/node-jsonwebtoken](https://github.com/auth0/node-jsonwebtoken)\r\n*/const authToken = '123456';app.get('/api/auth/user', (req, res) => {\r\n  const authHeader = req.headers.authorization || '';\r\n  const match = authHeader.match(/Bearer (.+)/); const token = match[1]; if (token !== authToken) {\r\n    return res.status(401).send('Unauthorized');\r\n  } else {\r\n    return res.status(200).json({\r\n      currentUser: {\r\n        full_name: 'John Doe',\r\n      }\r\n    });\r\n  }\r\n});const port = process.env.PORT || 8080;app.listen(port, () => console.log(`App is listening on [http://localhost:${port}`));](http://localhost:${port}`));/)\r\n```\r\n\r\nAll this route does is grab the Token that you pass into the Authorization header from the frontend and compare it to the authToken variable. If they are equal then you get a currentUser object back in response, if not then you get an error response.\r\n\r\n## Creating a secure route component\r\n\r\nLet’s jump back to the Frontend now!\r\n\r\nWe are going to create a wrapper that will take a component as an argument, check whether the user is authenticated, then return the component with the user data. If the user is not authenticated then instead of returning the component we can redirect using (next/router) to the homepage or login page.\r\n\r\n### Create api service\r\n\r\nIn order to respect the principle of separation of concerns, we will create a file which we will call api-service.ts inside a folder called helpers.\r\n\r\nWe shall create a simple fetch request to our backend user authentication endpoint. We need to pass an auth token in the Authorization header to check whether the token is valid. Even if the user has a token from a previous valid login, the token could be expired, therefore we always need to check.\r\n\r\n```\r\n**_./helpers/api-service.ts_**const apiBaseUrl: string = process.env.NODE_ENV === 'production'\r\n  ? 'https://example.com/api'\r\n  : 'http://localhost:8080/api';export const findUser = (token: string) => fetch(`${apiBaseUrl}/auth/user`, {\r\n  method: 'GET',\r\n  headers: {\r\n    Authorization: `Bearer ${token}`,\r\n  },\r\n});\r\n```\r\n\r\n### Create the wrapper\r\n\r\nThe authRoute wrapper will pass the authenticated user data down into the component as a prop. If the user is not authenticated then they will be redirected to the login screen or homepage.\r\n\r\nFirst of all, to ensure that the wrapper doesn’t have any strange side effects, we will just create the wrapper and pass the props down into the returned component.\r\n\r\n```\r\n**_./authentication/authRoute.tsx_**const authRoute = (Component) => {\r\n  return (props) => {\r\n    return <Component {...props} />;\r\n  }\r\n};export default authRoute;\r\n```\r\n\r\nHere it is important to note that we are not doing anything to the inner component. So if we were to wrap a component with this code then the component should act as if this wrapper is not even there.\r\n\r\n### Authenticating the user\r\n\r\nBefore returning the component, we can now authenticate the user. To do this we are going to add the following variables\r\n\r\n```\r\nconst router = useRouter();\r\nconst [user, setUser] = useState(null);\r\nconst [authenticated, setAuthenticated] = useState(false);\r\n```\r\n\r\nThe user variable and the authenticated variable will store the user data and authenticated state respectively. The router variable will allow us to redirect the unauthenticated user to safety (homepage or login page).\r\n\r\n```\r\n**_./authentication/authRoute.tsx_**const authRoute = (Component) => {\r\n  return (props) => {\r\n    const router = useRouter();\r\n    const [user, setUser] = useState(null);\r\n    const [authenticated, setAuthenticated] = useState(false); return <Component {...props} />;\r\n  }\r\n};export default authRoute;\r\n```\r\n\r\nWe then can authenticate the user using the `findUser` helper function we wrote earlier. Do do this we are going to use the `useEffect` hook and async/await as follows.\r\n\r\n```\r\nuseEffect(() => {\r\n  const checkToken = async () => {\r\n    const token = localStorage.getItem(\"token\");\r\n\r\n    if (!token) {\r\n      router.replace(\"/\");\r\n    } else { /* Here you would normally pass in the token to findUser but we are going to pass in '123456' to get a valid response from the server */ /* const response: any = await findUser(JSON.parse(token));*/\r\n\r\n      const response: any = await findUser('123456'); if (!response.ok) {\r\n        localStorage.removeItem(\"token\");\r\n        router.replace(\"/\");\r\n      } else {\r\n        const userData = await response.json();\r\n        if (!userData.currentUser) {\r\n          router.replace(\"/\");\r\n          localStorage.removeItem('token');\r\n        } else {\r\n          setUser(userData.currentUser);\r\n          setAuthenticated(true);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  checkToken();\r\n}, []);\r\n```\r\n\r\nIn order to be able to check whether the user that is trying to access this secure route is authenticated we need to get access to the access token that in our case is saved in local storage. Depending on your setup this might be inside the session storage or a cookie.\r\n\r\nWe check whether the token exists in local storage and if it doesn’t then we don’t need to go any further in the process and we can redirect the user to the homepage or login page.\r\n\r\nOnce we have a token, we are going to use our `findUser` service function to query our API. When we get a response from the server we need to check whether there were any errors and act accordingly. In the code below you can see that if there is an error we redirect the user to the homepage.\r\n\r\n```\r\nconst response: any = await findUser(JSON.parse(token));if (!response.ok) {\r\n  localStorage.removeItem(\"token\");\r\n  router.replace(\"/\");\r\n}\r\n```\r\n\r\nThe last thing we do in this useEffect is to check whether we receive the right object and if so we set the user state to that object and toggle authenticated to true and then call the checkToken function.\r\n\r\n```\r\nif (!userData.currentUser) {\r\nrouter.replace(\"/\");\r\nlocalStorage.removeItem('token');\r\n} else {\r\nsetUser(userData.currentUser);\r\nsetAuthenticated(true);\r\n}\r\n```\r\n\r\nRemember in the beginning of this article we mentioned having a reception area where we could check if the user is authenticated before letting them into the room? Well now we will code the final piece in this authRoute puzzle.\r\n\r\nRight after the `useEffect` we shall add the following if statement:\r\n\r\n```\r\nif (authenticated) {\r\nreturn <Component {...props} user={user} />;\r\n} else {\r\nreturn null;\r\n}\r\n```\r\n\r\nAs you can see, this if statement wraps the initial return component that we coded at the beginning and adds the user object as a prop to the component.\r\n\r\n### What does the whole wrapper look like ?\r\n\r\n```\r\n**_./authentication/authRoute.tsx_**\r\nimport { useRouter } from \"next/router\";\r\nimport { useEffect, useState } from \"react\";\r\nimport { findUser } from '../helpers/api-service';const authRoute = (Component) => {\r\n  return (props) => {\r\n    const router = useRouter();\r\n    const [user, setUser] = useState(null);\r\n    const [authenticated, setAuthenticated] = useState(false);          useEffect(() => {\r\n      const checkToken = async () => {\r\n        const token = localStorage.getItem(\"token\");\r\n\r\n        if (!token) {\r\n          router.replace(\"/\");\r\n        } else {\r\n          const response: any = await findUser(JSON.parse(token));           if (!response.ok) {\r\n            localStorage.removeItem(\"token\");\r\n            router.replace(\"/\");\r\n          } else {\r\n            const userData = await response.json();\r\n            if (!userData.currentUser) {\r\n              router.replace(\"/\");\r\n              localStorage.removeItem('token');\r\n            } else {\r\n              setUser(userData.currentUser);\r\n              setAuthenticated(true);\r\n            }\r\n          }\r\n        }\r\n      }\r\n      checkToken();\r\n    }, []);\r\n\r\n    if (authenticated) {\r\n      return <Component {...props} user={user} />;\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n}; export default authRoute;\r\n```\r\n\r\n### How does this work with an actual component?\r\n\r\nNow the authentication wrapper is finished and we can test our wrapper on a simple component.\r\n\r\nCreate a dashboard component in your pages folder and add the following code.\r\n\r\n```\r\n**_./pages/dashboard.tsx_**\r\nimport React from 'react';\r\nimport authRoute from './authRoute.tsx;const Dashboard = ({ user }) => {\r\n  return (\r\n    <>\r\n      <h1>{`Hello ${user.full_name}}</h1>\r\n    </>\r\n  )\r\n};export default authRoute(Dashboard);\r\n```\r\n\r\n### Run the local version of your app\r\n\r\n```\r\n$ npm run dev\r\n```\r\n\r\nThis is the output that you should see in your browser.\r\n![](/assets/images/blog/10.1.png)\r\n\r\n_Screenshot http://localhost:3000/dashboard_\r\n\r\n## Conclusion\r\n\r\nThere are a few ways to deal with secure routes in React and in Nextjs but this way ensures that you always have access to the authenticated data when the page is rendered, if not you will end up on a login page or homepage in our case.\r\n","data":{"draft":false,"image":"/assets/images/blog/10.jpg","title":"Secure routing in NextJS with TypeScript","tags":["react"],"date":"2021-07-09T00:00:00.000Z"},"slug":"9-secure-routing-in-next-js-with-type-script"},{"content":"\r\nClean code is more than just working code. Clean code is easy to read, simple to understand, and neatly organized. In this article, we’ll look at eight ways we can write cleaner React code.\r\n\r\nWhen going through these suggestions, it’s important to remember that’s exactly what they are: suggestions. If you disagree with any of them, that’s completely fine. However, these are practices that I’ve found helpful in writing my own React code.\r\n\r\nLet’s dive in!\r\n\r\n### 1. Conditional Rendering Only for One Condition\r\n\r\nIf you need to conditionally render something when a condition is `true` and not render anything when a condition is `false`, don’t use a ternary operator. Use the `&&` operator instead.\r\n\r\nBad example:\r\n\r\n```\r\nimport React, { useState } from 'react'\r\n\r\nexport const ConditionalRenderingWhenTrueBad = () => {\r\n  const [showConditionalText, setShowConditionalText] = useState(false)\r\n\r\n  const handleClick = () =>\r\n    setShowConditionalText(showConditionalText => !showConditionalText)\r\n\r\n  return (\r\n    <div>\r\n      <button onClick={handleClick}>Toggle the text</button>\r\n      {showConditionalText ? <p>The condition must be true!</p> : null}\r\n    </div>\r\n  )\r\n}\r\n```\r\n\r\nGood example:\r\n\r\n```\r\nimport React, { useState } from 'react'\r\n\r\nexport const ConditionalRenderingWhenTrueGood = () => {\r\n  const [showConditionalText, setShowConditionalText] = useState(false)\r\n\r\n  const handleClick = () =>\r\n    setShowConditionalText(showConditionalText => !showConditionalText)\r\n\r\n  return (\r\n    <div>\r\n      <button onClick={handleClick}>Toggle the text</button>\r\n      {showConditionalText && <p>The condition must be true!</p>}\r\n    </div>\r\n  )\r\n}\r\n```\r\n\r\n### 2. Conditional Rendering on Either Condition\r\n\r\nIf you need to conditionally render one thing when a condition is `true` and render a different thing when the condition is `false`, use a ternary operator.\r\n\r\nBad example:\r\n\r\n```\r\nimport React, { useState } from 'react'\r\n\r\nexport const ConditionalRenderingBad = () => {\r\n  const [showConditionOneText, setShowConditionOneText] = useState(false)\r\n\r\n  const handleClick = () =>\r\n    setShowConditionOneText(showConditionOneText => !showConditionOneText)\r\n\r\n  return (\r\n    <div>\r\n      <button onClick={handleClick}>Toggle the text</button>\r\n      {showConditionOneText && <p>The condition must be true!</p>}\r\n      {!showConditionOneText && <p>The condition must be false!</p>}\r\n    </div>\r\n  )\r\n}\r\n```\r\n\r\nGood example:\r\n\r\n```\r\nimport React, { useState } from 'react'\r\n\r\nexport const ConditionalRenderingGood = () => {\r\n  const [showConditionOneText, setShowConditionOneText] = useState(false)\r\n\r\n  const handleClick = () =>\r\n    setShowConditionOneText(showConditionOneText => !showConditionOneText)\r\n\r\n  return (\r\n    <div>\r\n      <button onClick={handleClick}>Toggle the text</button>\r\n      {showConditionOneText ? (\r\n        <p>The condition must be true!</p>\r\n      ) : (\r\n        <p>The condition must be false!</p>\r\n      )}\r\n    </div>\r\n  )\r\n}\r\n```\r\n\r\n### 3. Boolean Props\r\n\r\nA truthy prop can be provided to a component with just the prop name without a value like this: `myTruthyProp`. Writing it like `myTruthyProp={true}` is unnecessary.\r\n\r\nBad example:\r\n\r\n```\r\nimport React from 'react'\r\n\r\nconst HungryMessage = ({ isHungry }) => (\r\n  <span>{isHungry ? 'I am hungry' : 'I am full'}</span>\r\n)\r\n\r\nexport const BooleanPropBad = () => (\r\n  <div>\r\n    <span>\r\n      <b>This person is hungry: </b>\r\n    </span>\r\n    <HungryMessage isHungry={true} />\r\n    <br />\r\n    <span>\r\n      <b>This person is full: </b>\r\n    </span>\r\n    <HungryMessage isHungry={false} />\r\n  </div>\r\n)\r\n```\r\n\r\nGood example:\r\n\r\n```\r\nimport React from 'react'\r\n\r\nconst HungryMessage = ({ isHungry }) => (\r\n  <span>{isHungry ? 'I am hungry' : 'I am full'}</span>\r\n)\r\n\r\nexport const BooleanPropGood = () => (\r\n  <div>\r\n    <span>\r\n      <b>This person is hungry: </b>\r\n    </span>\r\n    <HungryMessage isHungry />\r\n    <br />\r\n    <span>\r\n      <b>This person is full: </b>\r\n    </span>\r\n    <HungryMessage isHungry={false} />\r\n  </div>\r\n)\r\n```\r\n\r\n### 4. String Props\r\n\r\nA string prop value can be provided in double-quotes without the use of curly braces or backticks.\r\n\r\nBad example:\r\n\r\n```\r\nimport React from 'react'\r\n\r\nconst Greeting = ({ personName }) => <p>Hi, {personName}!</p>\r\n\r\nexport const StringPropValuesBad = () => (\r\n  <div>\r\n    <Greeting personName={\"John\"} />\r\n    <Greeting personName={'Matt'} />\r\n    <Greeting personName={`Paul`} />\r\n  </div>\r\n)\r\n```\r\n\r\nGood example:\r\n\r\n```\r\nimport React from 'react'\r\n\r\nconst Greeting = ({ personName }) => <p>Hi, {personName}!</p>\r\n\r\nexport const StringPropValuesGood = () => (\r\n  <div>\r\n    <Greeting personName=\"John\" />\r\n    <Greeting personName=\"Matt\" />\r\n    <Greeting personName=\"Paul\" />\r\n  </div>\r\n)\r\n```\r\n\r\n### 5. Event Handler Functions\r\n\r\nIf an event handler only takes a single argument for the `Event` object, you can just provide the function as the event handler like this: `onChange={handleChange}`. You don't need to wrap the function in an anonymous function like this: `onChange={e => handleChange(e)}`.\r\n\r\nBad example:\r\n\r\n```\r\nimport React, { useState } from 'react'\r\n\r\nexport const UnnecessaryAnonymousFunctionsBad = () => {\r\n  const [inputValue, setInputValue] = useState('')\r\n\r\n  const handleChange = e => {\r\n    setInputValue(e.target.value)\r\n  }\r\n\r\n  return (\r\n    <>\r\n      <label htmlFor=\"name\">Name: </label>\r\n      <input id=\"name\" value={inputValue} onChange={e => handleChange(e)} />\r\n    </>\r\n  )\r\n}\r\n```\r\n\r\nGood example:\r\n\r\n```\r\nimport React, { useState } from 'react'\r\n\r\nexport const UnnecessaryAnonymousFunctionsGood = () => {\r\n  const [inputValue, setInputValue] = useState('')\r\n\r\n  const handleChange = e => {\r\n    setInputValue(e.target.value)\r\n  }\r\n\r\n  return (\r\n    <>\r\n      <label htmlFor=\"name\">Name: </label>\r\n      <input id=\"name\" value={inputValue} onChange={handleChange} />\r\n    </>\r\n  )\r\n}\r\n```\r\n\r\n### 6. Passing Components As Props\r\n\r\nWhen passing a component as a prop to another component, you don’t need to wrap this passed component in a function if the component does not accept any props.\r\n\r\nBad example:\r\n\r\n```\r\nimport React from 'react'\r\n\r\nconst CircleIcon = () => (\r\n  <svg height=\"100\" width=\"100\">\r\n    <circle cx=\"50\" cy=\"50\" r=\"40\" stroke=\"black\" stroke-width=\"3\" fill=\"red\" />\r\n  </svg>\r\n)\r\n\r\nconst ComponentThatAcceptsAnIcon = ({ IconComponent }) => (\r\n  <div>\r\n    <p>Below is the icon component prop I was given:</p>\r\n    <IconComponent />\r\n  </div>\r\n)\r\n\r\nexport const UnnecessaryAnonymousFunctionComponentsBad = () => (\r\n  <ComponentThatAcceptsAnIcon IconComponent={() => <CircleIcon />} />\r\n)\r\n```\r\n\r\nGood example:\r\n\r\n```\r\nimport React from 'react'\r\n\r\nconst CircleIcon = () => (\r\n  <svg height=\"100\" width=\"100\">\r\n    <circle cx=\"50\" cy=\"50\" r=\"40\" stroke=\"black\" stroke-width=\"3\" fill=\"red\" />\r\n  </svg>\r\n)\r\n\r\nconst ComponentThatAcceptsAnIcon = ({ IconComponent }) => (\r\n  <div>\r\n    <p>Below is the icon component prop I was given:</p>\r\n    <IconComponent />\r\n  </div>\r\n)\r\n\r\nexport const UnnecessaryAnonymousFunctionComponentsGood = () => (\r\n  <ComponentThatAcceptsAnIcon IconComponent={CircleIcon} />\r\n)\r\n```\r\n\r\n### 7. Undefined Props\r\n\r\nUndefined props are excluded, so don’t worry about providing an `undefined` fallback if it's OK for the prop to be undefined.\r\n\r\nBad example:\r\n\r\n```\r\nimport React from 'react'\r\n\r\nconst ButtonOne = ({ handleClick }) => (\r\n  <button onClick={handleClick || undefined}>Click me</button>\r\n)\r\n\r\nconst ButtonTwo = ({ handleClick }) => {\r\n  const noop = () => {}\r\n\r\n  return <button onClick={handleClick || noop}>Click me</button>\r\n}\r\n\r\nexport const UndefinedPropsBad = () => (\r\n  <div>\r\n    <ButtonOne />\r\n    <ButtonOne handleClick={() => alert('Clicked!')} />\r\n    <ButtonTwo />\r\n    <ButtonTwo handleClick={() => alert('Clicked!')} />\r\n  </div>\r\n)\r\n```\r\n\r\nGood example:\r\n\r\n```\r\nimport React from 'react'\r\n\r\nconst ButtonOne = ({ handleClick }) => (\r\n  <button onClick={handleClick}>Click me</button>\r\n)\r\n\r\nexport const UndefinedPropsGood = () => (\r\n  <div>\r\n    <ButtonOne />\r\n    <ButtonOne handleClick={() => alert('Clicked!')} />\r\n  </div>\r\n)\r\n```\r\n\r\n### 8. Setting State That Relies on the Previous State\r\n\r\nAlways set state as a function of the previous state if the new state relies on the previous state. React state updates can be batched, and not writing your updates this way can lead to unexpected results.\r\n\r\nBad example:\r\n\r\n```\r\nimport React, { useState } from 'react'\r\n\r\nexport const PreviousStateBad = () => {\r\n  const [isDisabled, setIsDisabled] = useState(false)\r\n\r\n  const toggleButton = () => setIsDisabled(!isDisabled)\r\n\r\n  const toggleButton2Times = () => {\r\n    for (let i = 0; i < 2; i++) {\r\n      toggleButton()\r\n    }\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      <button disabled={isDisabled}>\r\n        I'm {isDisabled ? 'disabled' : 'enabled'}\r\n      </button>\r\n      <button onClick={toggleButton}>Toggle button state</button>\r\n      <button onClick={toggleButton2Times}>Toggle button state 2 times</button>\r\n    </div>\r\n  )\r\n}\r\n```\r\n\r\nGood example:\r\n\r\n```\r\nimport React, { useState } from 'react'\r\n\r\nexport const PreviousStateGood = () => {\r\n  const [isDisabled, setIsDisabled] = useState(false)\r\n\r\n  const toggleButton = () => setIsDisabled(isDisabled => !isDisabled)\r\n\r\n  const toggleButton2Times = () => {\r\n    for (let i = 0; i < 2; i++) {\r\n      toggleButton()\r\n    }\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      <button disabled={isDisabled}>\r\n        I'm {isDisabled ? 'disabled' : 'enabled'}\r\n      </button>\r\n      <button onClick={toggleButton}>Toggle button state</button>\r\n      <button onClick={toggleButton2Times}>Toggle button state 2 times</button>\r\n    </div>\r\n  )\r\n}\r\n```\r\n\r\nThe following practices are not React-specific but rather good practices for writing clean code in JavaScript (or any programming language, for that matter).\r\n\r\n- Extract complex logic into clearly named functions.\r\n- Extract magic numbers into constants.\r\n- Use clearly named variables.\r\n","data":{"draft":false,"image":"/assets/images/blog/8.jpg","title":"Write Clean React Code","tags":["react"],"date":"2021-02-24T00:00:00.000Z"},"slug":"8-write-clean-react-code"},{"content":"\r\nNextjs is very popular server rendering library which so many people use it for their development purposes.\r\n\r\nThere are also so many ui libraries for server side rendering frameworks and Material UI is one of them.\r\n\r\nMaterial UI offers React components for faster and easier web development. You can create your own design system, or start with Material Design.\r\n\r\nYou can find many useful information from their websites and components you would like to use it in your project.\r\n\r\n[**Material UI library**](https://material-ui.com/)\r\n\r\n## How to use Next.js with Material UI\r\n\r\nThere are some requirements we should do to use material UI in next.js projects.\r\n\r\n1- Fixing the resolution order\r\n\r\n2- Removing the server side injected CSS\r\n\r\n**Resolution order** in our application needs to as\r\n\r\nOn the server:\r\n\r\n1. app.getInitialProps\r\n2. page.getInitialProps\r\n3. document.getInitialProps\r\n4. app.render\r\n5. page.render\r\n6. document.renderOn the server with error:\r\n7. document.getInitialProps\r\n8. app.render\r\n9. page.render\r\n10. document.renderOn the client\r\n11. app.getInitialProps\r\n12. page.getInitialProps\r\n13. app.render\r\n14. page.render\r\n\r\n### Why we should use it like that?\r\n\r\nServer side rendering frameworks can be a bit tricky sometimes about stylings.\r\n\r\nIf you having issues like flickering screen after you change your root in next.js you should do these changes in your application.\r\n\r\n### How to install and use material UI with next.js\r\n\r\nInstall material-ui to existing next.js project\r\n\r\nyarn\r\n\r\nyarn add @material-ui/core\r\n\r\nnpm\r\n\r\nnpm install @material-ui/core\r\n\r\nIf you are using \\_document.js file already adapt it yours or create new file.\r\n\r\n**\\_document.js**\r\n\r\n```\r\n/* eslint-disable react/jsx-filename-extension */\r\nimport React from 'react';\r\nimport Document, {\r\n  Html, Main, NextScript,\r\n} from 'next/document';\r\nimport { ServerStyleSheets } from '@material-ui/core/styles';\r\n\r\nexport default class MyDocument extends Document {\r\n  render() {\r\n    return (\r\n      <Html lang=\"en\">\r\n        <body>\r\n          <Main />\r\n          <NextScript />\r\n        </body>\r\n      </Html>\r\n    );\r\n  }\r\n}\r\n\r\n// `getInitialProps` belongs to `_document` (instead of `_app`),\r\n// it's compatible with server-side generation (SSG).\r\nMyDocument.getInitialProps = async (ctx) => {\r\n\r\n  // Render app and page and get the context of the page with collected side effects.\r\n  const sheets = new ServerStyleSheets();\r\n  const originalRenderPage = ctx.renderPage;\r\n\r\n  ctx.renderPage = () => originalRenderPage({\r\n    enhanceApp: (App) => (props) => sheets.collect(<App {...props} />),\r\n  });\r\n\r\n  const initialProps = await Document.getInitialProps(ctx);\r\n\r\n  return {\r\n    ...initialProps,\r\n    // Styles fragment is rendered after the app and page rendering finish.\r\n    styles: [...React.Children.toArray(initialProps.styles), sheets.getStyleElement()],\r\n  };\r\n};\r\n```\r\n\r\nIf you are using \\_app.js file already adapt it yours or create new file.\r\n\r\n**\\_app.js**\r\n\r\nThe most important part here is the removing the server side injected CSS.\r\n\r\n```\r\nReact.useEffect(() => {\r\n  // Remove the server-side injected CSS.\r\n  const jssStyles = **_document_**.querySelector('#jss-server-side');\r\n  if (jssStyles) {\r\n    jssStyles.parentElement.removeChild(jssStyles);\r\n  }\r\n}, []);\r\n```\r\n\r\n```\r\nimport React from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport Head from 'next/head';\r\nimport { ThemeProvider } from '@material-ui/core/styles';\r\nimport CssBaseline from '@material-ui/core/CssBaseline';\r\nimport theme from '../src/theme';\r\n\r\nexport default function MyApp(props) {\r\n  const { Component, pageProps } = props;\r\n\r\n  React.useEffect(() => {\r\n    // Remove the server-side injected CSS.\r\n    const jssStyles = document.querySelector('#jss-server-side');\r\n    if (jssStyles) {\r\n      jssStyles.parentElement.removeChild(jssStyles);\r\n    }\r\n  }, []);\r\n\r\n  return (\r\n    <React.Fragment>\r\n      <Head>\r\n        <title>My page</title>\r\n        <meta name=\"viewport\" content=\"minimum-scale=1, initial-scale=1, width=device-width\" />\r\n      </Head>\r\n      <ThemeProvider theme={theme}>\r\n        {/* CssBaseline kickstart an elegant, consistent, and simple baseline to build upon. */}\r\n        <CssBaseline />\r\n        <Component {...pageProps} />\r\n      </ThemeProvider>\r\n    </React.Fragment>\r\n  );\r\n}\r\n\r\nMyApp.propTypes = {\r\n  Component: PropTypes.elementType.isRequired,\r\n  pageProps: PropTypes.object.isRequired,\r\n};\r\n```\r\n\r\nYour application is ready to go! You can test it and now flickering issues is gone and you can able to use material UI properly on your nextjs applications.\r\n","data":{"draft":false,"image":"/assets/images/blog/6.jpg","title":"Next.js with Material-UI","tags":["Next.JS","react","react-hooks"],"date":"2020-06-19T00:00:00.000Z"},"slug":"7-next-js-with-material-ui"},{"content":"\r\n**Problem: the try-catch insanity**\r\n\r\nAgain, I admit I have done it, we all have done it. Another copy and paste job from some tutorial that written up in 2 minutes for the purpose of learning NOT fit for production code that is littered with try-catch.\r\n\r\nHere is a contrived example:\r\n\r\n```\r\nexport function* requestCat() {\r\n try {\r\n  const resp  = yield call(catService.get)\r\n  yield put(actions.requestCatSuccess(resp))\r\n } catch (err) {\r\n  yield put(actions.requestCatError(err))\r\n }\r\n}\r\n\r\nexport function* requestDog() {\r\n try {\r\n  const resp  = yield call(dogService.get)\r\n  yield put(actions.requestDogSuccess(resp))\r\n } catch (err) {\r\n  yield put(actions.requestDogError(err))\r\n }\r\n}\r\n\r\nexport function* catsNDogsSaga() {\r\n yield takeLatest(actions.GET_CAT_REQUEST, requestCat)\r\n yield takeLatest(actions.GET_DOG_REQUEST, requestDog)\r\n}\r\n```\r\n\r\nAs you can see, this is not very good for our mental healthy, let’s see if we can do it better.\r\n\r\n**Option 1: try-catch wrapper**\r\n\r\nAs per Unix Error handling principle “If we don’t have anything interesting to say, keep it quiet”. Meaning if we don’t have any value to add to solving the error, let it bubble up to the root error handler which is Option-2 below.\r\n\r\nIn the case that we don’t want error to bubble up to root Saga, or we are interested in handling in a specific saga, we wrap the saga generator in a safe generator.\r\n\r\nonError handler can dispatch an event if we want the error to be handled somewhere else in the code base.\r\n\r\nconst onError = (err:any) => yield put(actions.requestError(err))\r\n\r\n```\r\nimport * as actions from '../actions'\r\nimport { catService } from '../catServices'\r\nimport { put, call, takeLatest } from 'redux-saga/effects'\r\n\r\nconst safe = (handler:any = null, saga:any, ...args:any) => function* (action:any) {\r\n  try {\r\n    yield call(saga, ...args, action)\r\n  } catch (err) {\r\n    yield call(handler, ...args, err)\r\n  }\r\n}\r\n\r\nexport function* requestCat() {\r\n  const cats = yield call(catService.get)\r\n  yield put(actions.requestCatSuccess(cats))\r\n}\r\n\r\nexport function* requestDog() {\r\n  const dogs = yield call(catService.get)\r\n  yield put(actions.requestDogSuccess(dogs))\r\n}\r\n\r\nconst onError = (err:any) => {\r\n  console.log(err)\r\n}\r\n\r\nexport function* requestCatSaga() {\r\n yield takeLatest(actions.GET_CAT_REQUEST, safe(onError,requestCat))\r\n yield takeLatest(actions.GET_DOG_REQUEST, safe(onError, requestDog))\r\n}\r\n```\r\n\r\n**Option 2: Global error handler**\r\n\r\nSo we have to options here:\r\n\r\n1. Add an onError function to the middleware option.\r\n\r\n2. Chain a catch function at returned promise of sagaMiddleware.run()\r\n\r\n```\r\nimport { createStore, applyMiddleware, compose } from 'redux'\r\nimport RootReducer from './reducers'\r\nimport createSagaMiddleware from 'redux-saga'\r\nimport rootSaga from './sagas'\r\n\r\n//option 1\r\nconst sagaMiddleware = createSagaMiddleware({\r\n  onError: (err) => {\r\n    store.dispatch({ type: 'ERROR', payload: err })\r\n  }\r\n})\r\n\r\nconst composeEnhancers = ((window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ &&\r\n  (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({ trace: true, traceLimit: 25 }))\r\n  || compose\r\n\r\nconst store = createStore(\r\n  RootReducer,\r\n  composeEnhancers(applyMiddleware(sagaMiddleware))\r\n)\r\n\r\n// option 2\r\nsagaMiddleware.run(rootSaga).done.catch((e:any) => {\r\n  console.log({ message: e.message, source: 'sagaError', stacktrace: e.sagaStack })\r\n  store.dispatch({ type: 'ERROR', payload: e })\r\n})\r\n\r\n// option 2 if on latest mw version\r\nsagaMiddleware.run(rootSagas, store.dispatch).toPromise().catch(e => {\r\n    logger.error({ message: e.message, source: 'sagaError', stacktrace: e.sagaStack })\r\n  store.dispatch({ type: 'ERROR', payload: e })\r\n});\r\n\r\nexport default store\r\n```\r\n","data":{"draft":false,"image":"/assets/images/blog/7.jpg","title":"Redux Saga Error Handling","tags":["react","redux-saga"],"date":"2020-03-02T00:00:00.000Z"},"slug":"6-redux-saga-error-handling"},{"content":"\r\nIf you start using React-Hooks, and your component might need a life cycle method at some point. And, that is when you start using **useEffect()** (a.k.a **Effect Hook**). Then boom!!, you have encountered **an infinite loop behavior,** and you have no idea why the hell is that. If that happens, this article will explain to you why, and how can you prevent.\r\n\r\n## Example Using Effect Hook\r\n\r\nThe code snippet below is the example of using Effect Hook, but it has an infinite loop behavior.\r\n\r\n![](/assets/images/blog/5.1.png)\r\n\r\nA problem snippet code for causing an infinite behavior\r\n\r\n## What does this code do?\r\n\r\n- In a nutshell, the component **_“DisplayName”_** has two states which are “**_name”_** and “**_userId”._**\r\n- And it has a function called **_“fetchUser()”_** which handle fetching data from API and set the **_“name”._**\r\n- Then, there is“**_useEffect()”_** which will call the “**_fetchUser()”_** after rendering a DOM element.\r\n\r\n## Where is the problem?\r\n\r\n- The “**_useEffect()”,_** will run after the initial render, then invoke the “**_fetchUser()”._**\r\n- Inside the “**_fetchUser_**”, it will update the state “**_name_**” on line 9. Then it will trigger the component to re-render again.\r\n- As a result, “**_useEffect()”_** will run again and update the state. Next, the whole process repeats again, and you're trapped inside an infinite loop.\r\n\r\n![](/assets/images/blog/5.2.png)\r\n\r\nThe diagram of Infinite loop behavior\r\n\r\n## The Solution for Infinite Behavior\r\n\r\n![](/assets/images/blog/5.3.png)\r\n\r\nA solution snippet code for an infinite behavior\r\n\r\n> “You can tell React to _skip_ applying an effect if certain values haven’t changed between re-renders. To do so, pass an array as an optional second argument to useEffect”, from the official [documentation](https://reactjs.org/docs/hooks-effect.html#tip-optimizing-performance-by-skipping-effects).\r\n\r\nIn the snippet above, we now have an optional second argument **[userId]** passed in the “**_useEffect()_**”.\r\n\r\n**By providing [userId] as a second argument**_,_ we are just telling “**_useEffect()”_** to run only if the certain value (userId) has changed between the component re-renders.\r\n\r\nHere below, I’ve provided a simple diagram for the sake of simplicity.\r\n\r\n![](/assets/images/blog/5.4.png)\r\n\r\nThe diagram of skipping useEffect\r\n\r\nAnd now, we’ve escaped from the infinite world !!.\r\n","data":{"draft":false,"image":"/assets/images/blog/5.jpg","title":"Taming React Hook useEffect Infinite Loop Inside","tags":["react","react-hooks"],"date":"2019-07-24T00:00:00.000Z"},"slug":"5-how-to-fix-the-infinite-loop-inside-use-effect-react-hooks"},{"content":"\r\nThis post is going to cover this process use the Identity Scaffolding feature available in Visual Studio.\r\n\r\n## Sample\r\n\r\nFor this example, I’m starting with a new web app created using the following command.\r\n\r\ndotnet new webapp\r\n\r\nIf you have any of the .NET Core 3 previews installed I recommend adding a **global.json** file in the directory where the application is to be created before running the application creation. I had some issues with the scaffolding in the current preview. The following is the contents of my **global.json** for an example.\r\n\r\n{ \"sdk\": { \"version\": \"2.2.104\" } }\r\n\r\n## Scaffolding\r\n\r\nIn Visual Studio right-click on the project and select **Add > New Scaffolded Item**.\r\n\r\n![](/assets/images/blog/4.1.png)\r\n\r\nOn the **Add Scaffold** dialog in the left list select **Identity** in the middle area we want the **Identity** item and then click the **Add** button.\r\n![](/assets/images/blog/4.2.png)\r\n\r\nNext, on the **Add Identity** dialog, you get a chance to pick which parts of the provided identity you want to override. I’m going to take the default for all the values. The one exception is the **Data context class** which I’m using the plus button to the right of the field to add a new one since this project doesn’t currently have any data access in it. When done click the **Add** button.\r\n\r\n![](/assets/images/blog/4.3.png)\r\n\r\nAfter a minute or so identity generation will be complete and a text file will so with some follow up steps. Because of the project type, we started with the only one we need to do anything with is the entity framework migrations. The following are the instructions from the file that will get your database to create/updated with the new data needed to support ASP.NET Core’s Identity.\r\n\r\n> _The generated database code requires Entity Framework Core Migrations. Run the following commands:_\r\n>\r\n> _1. dotnet ef migrations add CreateIdentitySchema  \r\n> 2. dotnet ef database update_\r\n>\r\n> \\_Or from the Visual Studio Package Manager Console:\r\n>\r\n> 1. Add-Migration CreateIdentitySchema\r\n> 2. Update-Database\\_\r\n\r\nFinally, in the **Pages/Shared** directory open the **\\_Layout.cshtml** file and add the following to where you want to show the Register and Login links. I added this right after the existing navigation links.\r\n\r\n```\r\n<partial name=\"_LoginPartial\"/>\r\n```\r\n","data":{"draft":false,"image":"/assets/images/blog/4.jpg","title":"ASP.NET Core - Identity Scaffolding","tags":["dotnet","aspcore"],"date":"2019-04-08T00:00:00.000Z"},"slug":"4-asp-net-core-identity-scaffolding"},{"content":"\r\n**TL;DR** - Wrap your custom hook in a component and shallow render it to test implementation details.\r\n\r\n### Test Strategies\r\n\r\nThere are broadly two strategies to test our React codebase.\r\n\r\n1.  Testing user observable behaviour\r\n2.  Testing implementation details\r\n\r\n#### Testing user observable behaviour\r\n\r\nTesting user observable behaviour means writing tests against components that test\r\n\r\n- how the component is rendered\r\n- how the component is re-rendered when user interacts with the DOM\r\n- how props/state control what is rendered\r\n\r\nConsider the following component - `Greet`\r\n\r\n```\r\nfunction Greet({ user = 'User' }) {\r\n  const [name, setName] = React.useState(user);\r\n\r\n  return <div onClick={() => setName('Pinocchio')}>Hello, {name}!</div>;\r\n}\r\n\r\n```\r\n\r\nTesting the user observable behaviour in `Greet` would mean\r\n\r\n- test if `Greet` is rendered without crashing\r\n- test if `Hello, User!` is rendered when user prop is not passed\r\n- test if `Hello, Bruce!` is rendered when `Bruce` is passed as value to `user` prop\r\n- test if the text changes to `Hello, Pinocchio!` when the user clicks on the element\r\n\r\n#### Testing implementation details\r\n\r\nTesting implementation details means writing tests against state logic that test\r\n\r\n- how the state is initialized with default/prop values\r\n- how the state changes when handlers are invoked\r\n\r\nConsider the same component - `Greet`\r\n\r\n```\r\nfunction Greet({ user = 'User' }) {\r\n  const [name, setName] = React.useState(user);\r\n\r\n  return <div onClick={() => setName('Pinocchio')}>Hello, {name}!</div>;\r\n}\r\n\r\n```\r\n\r\nTesting implementation details in `Greet` would mean\r\n\r\n- test if `name` is set to default value `User` when user prop is not passed to `Greet`\r\n- test if `name` is set to prop value when user prop is passed to `Greet`\r\n- test if `name` is updated when `setName` is invoked\r\n\r\n### Testing custom hooks with Enzyme\r\n\r\n_Note: Please make sure your React version is `^16.8.5`. Hooks won't re-render components with enzyme shallow render in previous versions and the React team fixed it in this release. If your React version is below that, you might have to use enzyme mount and `.update()` your wrapper after each change to test the re-render._\r\n\r\nTesting implementation details might seem unnecessary and might even be considered as a bad practice when you are writing tests against components that contains presentational (UI) logic and render elements to the DOM. But **custom hooks** contain only **state logic** and it is imperative that we test the implementation details thoroughly so we know exactly how our custom hook will behave within a component.\r\n\r\nLet's write a custom hook to update and validate a form field.\r\n\r\n```\r\n/* useFormField.js */\r\n\r\nimport React from 'react';\r\n\r\nfunction useFormField(initialVal = '') {\r\n  const [val, setVal] = React.useState(initialVal);\r\n  const [isValid, setValid] = React.useState(true);\r\n\r\n  function onChange(e) {\r\n    setVal(e.target.value);\r\n\r\n    if (!e.target.value) {\r\n      setValid(false);\r\n    } else if (!isValid) setValid(true);\r\n  }\r\n\r\n  return [val, onChange, isValid];\r\n}\r\n\r\nexport default useFormField;\r\n\r\n```\r\n\r\n**As great as custom hooks are in abstracting away re-usable logic in our code, they do have one limitation. Even though they are just JavaScript functions they will work only inside React components. You cannot just invoke them and write tests against what a hook returns. You have to wrap them inside a React component and test the values that it returns.**\r\n\r\n- custom hooks cannot be tested like JavaScript functions\r\n- custom hooks should be wrapped inside a React component to test its behaviour\r\n\r\nThanks to the composibility of hooks, we could pass a hook as a prop to a component and everything will work exactly as how it's supposed to work. We can write a wrapper component to render and test our hook.\r\n\r\n```\r\n/* useFormField.test.js */\r\n\r\nfunction HookWrapper(props) {\r\n  const hook = props.hook ? props.hook() : undefined;\r\n  return <div hook={hook} />;\r\n}\r\n\r\n```\r\n\r\nNow we can access the hook like a JavaScript object and test its behaviour.\r\n\r\n```\r\n/* useFormField.test.js */\r\n\r\nimport React from 'react';\r\nimport { shallow } from 'enzyme';\r\nimport useFormField from './useFormField';\r\n\r\nfunction HookWrapper(props) {\r\n  const hook = props.hook ? props.hook() : undefined;\r\n  return <div hook={hook} />;\r\n}\r\n\r\nit('should set init value', () => {\r\n  let wrapper = shallow(<HookWrapper hook={() => useFormField('')} />);\r\n\r\n  let { hook } = wrapper.find('div').props();\r\n  let [val, onChange, isValid] = hook;\r\n  expect(val).toEqual('');\r\n\r\n  wrapper = shallow(<HookWrapper hook={() => useFormField('marco')} />);\r\n\r\n  // destructuring objects - {} should be inside brackets - () to avoid syntax error\r\n  ({ hook } = wrapper.find('div').props());\r\n  [val, onChange, isValid] = hook;\r\n  expect(val).toEqual('marco');\r\n});\r\n\r\n```\r\n\r\nThe full test suite for `useFormField` custom hook will look like this.\r\n\r\n```\r\n/* useFormField.test.js */\r\n\r\nimport React from 'react';\r\nimport { shallow } from 'enzyme';\r\nimport useFormField from './useFormField';\r\n\r\nfunction HookWrapper(props) {\r\n  const hook = props.hook ? props.hook() : undefined;\r\n  return <div hook={hook} />;\r\n}\r\n\r\ndescribe('useFormField', () => {\r\n  it('should render', () => {\r\n    let wrapper = shallow(<HookWrapper />);\r\n\r\n    expect(wrapper.exists()).toBeTruthy();\r\n  });\r\n\r\n  it('should set init value', () => {\r\n    let wrapper = shallow(<HookWrapper hook={() => useFormField('')} />);\r\n\r\n    let { hook } = wrapper.find('div').props();\r\n    let [val, onChange, isValid] = hook;\r\n    expect(val).toEqual('');\r\n\r\n    wrapper = shallow(<HookWrapper hook={() => useFormField('marco')} />);\r\n\r\n    // destructuring objects - {} should be inside brackets - () to avoid syntax error\r\n    ({ hook } = wrapper.find('div').props());\r\n    [val, onChange, isValid] = hook;\r\n    expect(val).toEqual('marco');\r\n  });\r\n\r\n  it('should set the right val value', () => {\r\n    let wrapper = shallow(<HookWrapper hook={() => useFormField('marco')} />);\r\n\r\n    let { hook } = wrapper.find('div').props();\r\n    let [val, onChange, isValid] = hook;\r\n    expect(val).toEqual('marco');\r\n\r\n    onChange({ target: { value: 'polo' } });\r\n\r\n    ({ hook } = wrapper.find('div').props());\r\n    [val, onChange, isValid] = hook;\r\n    expect(val).toEqual('polo');\r\n  });\r\n\r\n  it('should set the right isValid value', () => {\r\n    let wrapper = shallow(<HookWrapper hook={() => useFormField('marco')} />);\r\n\r\n    let { hook } = wrapper.find('div').props();\r\n    let [val, onChange, isValid] = hook;\r\n    expect(val).toEqual('marco');\r\n    expect(isValid).toEqual(true);\r\n\r\n    onChange({ target: { value: 'polo' } });\r\n\r\n    ({ hook } = wrapper.find('div').props());\r\n    [val, onChange, isValid] = hook;\r\n    expect(val).toEqual('polo');\r\n    expect(isValid).toEqual(true);\r\n\r\n    onChange({ target: { value: '' } });\r\n\r\n    ({ hook } = wrapper.find('div').props());\r\n    [val, onChange, isValid] = hook;\r\n    expect(val).toEqual('');\r\n    expect(isValid).toEqual(false);\r\n  });\r\n});\r\n\r\n```\r\n\r\nRendering the custom hook and accessing it as a prop should give us full access to its return values.\r\n\r\nIf you're using `useEffect` hook in your custom hook, make sure you wrap the `shallow` or `mount` call with [ReactTestUtils.act()](https://reactjs.org/docs/test-utils.html#act) to have the effects flushed out before assertions. Enzyme might support this internally soon but for now, this is required. More info on this here - [hooks-faq](https://reactjs.org/docs/hooks-faq.html#how-to-test-components-that-use-hooks).\r\n\r\n```\r\nact(() => {\r\n  wrapper = shallow(<HookWrapper />);\r\n});\r\n\r\n```\r\n\r\nAll code snippets in this post can be found in the repo - [testing-hooks](https://github.com/flexdinesh/testing-hooks) with a working example.\r\n\r\nHappy testing! 🎉\r\n","data":{"draft":false,"image":"/assets/images/blog/3.jpg","title":"React Hooks - Test custom hooks with Enzyme","tags":["react","redux"],"date":"2018-07-23T00:00:00.000Z"},"slug":"3-react-hooks-test-custom-hooks-with-enzyme"},{"content":"\r\nSeparate authentication from your Components with a dedicated authentication component.\r\n\r\nWhen writing [React](https://facebook.github.io/react/) applications with [Redux](https://github.com/reactjs/redux) and [react-router-redux](https://github.com/reactjs/react-router-redux) some routes in your application may require an authenticated user and others not. To separate the authentication concern we use a specific container that checks for the authentication and before rendering the child. If the authentication fails then you can respond by display an error or more likely redirect to login.\r\n\r\n## Route\r\n\r\nTo simplify the main render method we use a function to wrap the child in an `AuthenticatedComponent`, so it is clear in your main render method which parts of your application are protected.\r\n\r\n```\r\nReactDOM.render(\r\n  <Provider store={store}>\r\n    <Router history={history}>\r\n      <Route path=\"/\" component={AppParent}>\r\n        <Route path=\"login\" component={LoginContainer}/>\r\n        <Route path=\"logout\" component={LogoutContainer}/>\r\n        <Route path=\"about\" component={AboutPage}/>\r\n        <Route path=\"help\" component={HelpPage}/>\r\n        <Route path=\"user\" component={requireAuth(UserContainer)}/>\r\n        <Route path=\"admin\" component={requireAuth(AdminContainer)}/>\r\n        <Route path=\"main\" component={requireAuth(MainContainer)}>\r\n          <Route path=\"one\" component={FirstPage}/>\r\n          <Route path=\"two\" component={SecondPage}/>\r\n        </Route>\r\n      </Route>\r\n    </Router>\r\n  </Provider>,\r\n  document.getElementById('app')\r\n)\r\n```\r\n\r\n## Authenticated Component\r\n\r\nWe then implement the `requireAuth` function as follows. You may need to change the detail of the auth check depending on your authentication actions and you can make the `authFailed` function do whatever you like, in this example we redirect to login with the path so we can redirect back after a successful login.\r\n\r\n```\r\nimport React, { Component, PropTypes } from 'react'\r\nimport { connect } from 'react-redux'\r\nimport { push } from 'react-router-redux'\r\n\r\nexport function requireAuth(ChildComponent) {\r\n\r\n  class AuthenticatedComponent extends Component {\r\n\r\n    componentWillMount() {\r\n      this.checkAuth(this.props.isAuthenticated);\r\n    }\r\n\r\n    componentWillReceiveProps(nextProps) {\r\n      this.checkAuth(nextProps.isAuthenticated);\r\n    }\r\n\r\n    checkAuth(isAuthenticated) {\r\n      if (!isAuthenticated) {\r\n        this.props.authFailed();\r\n      }\r\n    }\r\n\r\n    render() {\r\n      return (\r\n        <div>\r\n         { this.props.isAuthenticated === true ?\r\n           <ChildComponent { ...this.props } /> : null }\r\n        </div>\r\n      )\r\n\r\n    }\r\n  }\r\n\r\n  const mapStateToProps = (state) => ({\r\n    auth: state.auth,\r\n    isAuthenticated: state.auth.login.isAuthenticated,\r\n  });\r\n\r\n  const mapDispatchToProps = (dispatch, ownProps) => {\r\n    return {\r\n      authFailed: () => {\r\n        let location = ownProps.location\r\n        let redirect = encodeURIComponent(location.pathname + location.search)\r\n        dispatch(push(`/login?next=${redirect}`))\r\n      },\r\n    }\r\n  }\r\n\r\n  return connect(mapStateToProps, mapDispatchToProps)(AuthenticatedComponent);\r\n\r\n}\r\n\r\n```\r\n\r\nThe auth details can be useful for the child components, say to show the username but not all children are likely to need it. A good way to do this is to make it a context object for the children. This can be done by adding the following to the class:\r\n\r\n```\r\nclass AuthenticatedComponent extends Component {\r\n\r\n  \\\\...\r\n\r\n  static childContextTypes = {\r\n    auth: PropTypes.object.isRequired\r\n  }\r\n\r\n  getChildContext() {\r\n    return {\r\n      auth: this.props.auth\r\n    }\r\n  }\r\n\r\n  \\\\...\r\n}\r\n```\r\n","data":{"draft":false,"image":"/assets/images/blog/1.webp","title":"Authenticated Container for React Router and Redux","tags":["react","redux"],"date":"2018-07-14T00:00:00.000Z"},"slug":"1-authenticated-container-react-router-redux"}]}